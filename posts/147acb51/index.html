<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>数算复习笔记 | C+V</title><meta name="keywords" content="数据结构与算法A"><meta name="author" content="C+V,2715768122@qq.com"><meta name="copyright" content="C+V"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="数算复习笔记"><meta name="application-name" content="数算复习笔记"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="数算复习笔记"><meta property="og:url" content="https://pku-cs-cjw.top/posts/147acb51/index.html"><meta property="og:site_name" content="C+V"><meta property="og:description" content="通知由于本篇过大，hexo架构渲染时有点问题，这里有pdf版本      引用站外地址                                                        pdf版本              有点多"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://pku-cs-cjw.top/img/default_cover.jpg"><meta property="article:author" content="C+V"><meta property="article:tag" content="可爱"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pku-cs-cjw.top/img/default_cover.jpg"><meta name="description" content="通知由于本篇过大，hexo架构渲染时有点问题，这里有pdf版本      引用站外地址                                                        pdf版本              有点多"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://pku-cs-cjw.top/posts/147acb51/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与各位大佬无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"Chat","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"sk-Ma8nmsjNn5A2huh6F66bBd59C6B7423888Fb52C7B96d3731","Referer":"https://burn.hair/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来C+V's blog！"},
  LA51: {"enable":true,"ck":"3JWBrTeuJco67s46","LingQueMonitorID":""},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://cjw-cs-pku.fun',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":""},
  root: '/',
  preloader: {"source":1},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: {"mode":"api","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🎮 电子游戏小菜登","🔨 crtl+c/v大专家","严重社交恐惧症 🤝","脚踏实地行动派 🏃","搬砖在行牛马人 🧱","壮汉人狠话不多 💢"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"距离上次更新已经过去了","messageNext":"天，文章内容可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: C+V","link":"链接: ","source":"来源: C+V","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'C+V',
  title: '数算复习笔记',
  postAI: '',
  pageFillDescription: '通知, 3. 考试范围和重点, 遗留问题, 第1章 概论, 数据结构, 逻辑结构, 存储结构, 抽象数据类型, x3Dx3D算法分析x3Dx3D, x3Dx3D算法的渐进分析x3Dx3D, x3Dx3D大O表示法x3Dx3D, 二分查找法时间复杂度推导, 一、二分查找法的基本原理, 二、时间复杂度的推导, 1. 每一步缩小查找范围的大小, 2. 确定最坏情况下需要的比较次数, 3. 递归关系的推导, 4. 示例说明, 三、结论, 第2章 线性表, 链表, 线性表实现方法的比较, 第3章 栈与队列, x3Dx3D栈的性质x3Dx3D, x3Dx3D栈的实现x3Dx3D, 栈的ADT, 顺序栈, 溢出, 链式栈, 链式栈的创建, 两者比较, x3Dx3D利用栈来消除递归x3Dx3D, 简单的递归转换, x3Dx3D尾递归x3Dx3D, x3Dx3D机械的递归转换x3Dx3D, 我们来看递归版本, x3Dx3D合法出栈序列x3Dx3D, 队列, 队列的ADT, x3Dx3D循环队列x3Dx3D, 实现, 链式队列, 作业题, 第4章 字符串, 串的KMP快速模式匹配算法, 算法复杂度分析, 第5章 二叉树, 思考题, 定义, 满二叉树, 完全二叉树, 扩充二叉树, 重要性质, x3Dx3D二叉树的周游x3Dx3D, x3Dx3D非递归深度优先遍历x3Dx3D, x3Dx3D广度优先遍历二叉树x3Dx3D, x3Dx3D二叉搜索树的插入和删除x3Dx3D, 二叉搜索树的插入, 思想, 删除, 未优化, 改进, x3Dx3D堆的建立和维护x3Dx3D, x3Dx3D构造Huffman树利用Huffman树进行编码、解码x3Dx3D, 建立Huffman编码树的过程, 编码过程, 译码, 第6章 树, x3Dx3D森林和二叉树的相互转换x3Dx3D, 森林转换成二叉树, 树换成二叉树, 二叉树转换成森林, 二叉树为树, 树的周游, x3Dx3D树的链式存储x3Dx3D, x3Dx3D父指针表示法及在并查集中的应用x3Dx3D, 并查集, x3Dx3D树的顺序存储方法x3Dx3D, 带右链的先根次序表示法, 带双标记位的先根次序表示法, 带度数的后根次序表示法, 带双标记的层次次序表示通知由于本篇过大架构渲染时有点问题这里有版本引用站外地址版本有点多考试范围和重点章以本文最后的内容为复习重点尤其是标出部分为重中之重考试时如果涉及到本大纲没有列出的内容那么试卷中会给出足够的定义和性质遗留问题第章概论一重要概念抽象数据结构数据逻辑结构数据存储结构算法算法分析时间代价空间代价数据结构的选择和评价二方法根据二元组画出图示逻辑结构注意边的方向根据要求设计数据结构算法的渐进分析方法算法分析的大表示法不要求掌握大大表示法数据结构涉及数据之间的逻辑关系数据在计算机中的存储表示和在这种结构上的一组能执行的操作运算三个方面三要素逻辑结构存储物理结构运算逻辑结构具体问题的数学抽象反映事物的组成和逻辑关系逻辑结构的表示存储结构抽象数据类型抽象数据类型由数据对象数据关系数据操作三个不可分割的部分组成的三元组抽象数据类型名数据对象数据对象的定义数据关系数据关系的定义数据操作基本操作的定义抽象数据类型名算法分析算法分析是对一个算法需要多少计算时间和存储时间作定量的分析判断所提出的算法是否符合现实情况时间和空间复杂性算法的渐进分析算法分析估计当数据规模逐步增大时时间或者空间资源开销的增长规模从数量级大小的比较来考虑当增大到一定值时资源开销的计算公式中影响最大的就是的幂次最高的项其他的常数项和低幂次项均可忽略不计大表示法二分查找法时间复杂度推导二分查找法是一种高效的查找算法适用于已排序的数组或列表它通过反复将查找范围缩小一半来快速定位目标元素其时间复杂度为下面将详细推导二分查找法的时间复杂度一二分查找法的基本原理假设有一个升序排列的数组包含个元素目标是查找某个特定的元素是否存在于数组中并找到其位置二分查找的步骤如下确定查找范围初始时查找范围为整个数组即从下标到找到中间元素计算中间下标然后比较与如果查找成功返回如果则目标元素只能在右半部分即更新查找范围为到如果则目标元素只能在左半部分即更新查找范围为到重复步骤直到找到目标元素或查找范围为空二时间复杂度的推导每一步缩小查找范围的大小在每一步操作中二分查找法将当前的查找范围缩小一半这意味着初始时查找范围大小为第一次比较后查找范围缩小到第二次比较后查找范围缩小到第次比较后查找范围缩小到确定最坏情况下需要的比较次数最坏情况下二分查找需要继续缩小查找范围直到查找范围大小为即解这个不等式因此最坏情况下需要的比较次数至少为递归关系的推导可以通过递归关系进一步确认时间复杂度设为在大小为的数组上进行二分查找的时间复杂度根据二分查找的步骤每次比较后将问题规模缩小一半并进行常数时间的比较操作因此递归关系为其中是常数时间比较操作的时间通过递归展开当即时递归终止由于是常数最终时间复杂度为示例说明假设有一个大小为的数组进行二分查找的步骤如下第一次比较查找范围个元素比较中间的第个元素第二次比较查找范围缩小到个元素比较中间的第个元素第三次比较查找范围缩小到个元素比较中间的第个元素第四次比较查找范围缩小到个元素比较中间的第个元素第五次比较查找范围缩小到个元素比较最终元素可以看到比较次数为对于一般情况大小为的数组最多需要次比较三结论二分查找法通过每次将查找范围缩小一半使得其时间复杂度为对数级别即这种高效的查找性能使得二分查找在处理大规模已排序数据时非常有用第章线性表一概念线性表单链表双链表循环表二方法顺序表上实现的运算链表上实现的运算指针操作的正确性顺序表和链表的比较链表插入和删除要注意边界链表检索链表插入链表删除非法删除点线性表实现方法的比较顺序表的主要优点没有使用指针不用花费额外开销线性表元素的访问非常便利链表的主要优点无需事先了解线性表的长度允许线性表的长度动态变化能够适应经常插入删除内部元素的情况顺序表适合存储静态数据链表适合动态数据第章栈与队列一概念栈队列循环队列二方法栈的性质用栈来生成序列栈的实现队列的性质用队列生成序列循环队列的实现利用栈来消除递归栈的灵活应用例如表达式求值中缀表达式转后缀表达式的算法后缀表达式求值算法栈的性质先进后出栈的实现栈的栈的元素类型为栈的运算集变为空栈入栈成功则返回真否则返回假返回栈顶内容并弹出成功返回真否则返回假返回栈顶内容但不弹出成功返回真否则返回假若栈已空返回真若栈已满返回真顺序栈溢出上溢当栈中已经有个元素时如果再做进栈操作所产生的无空间可用现象下溢空栈进行出栈所产生的无元素可删现象链式栈栈的链式存储结构是运算受限的链表指针方向从栈顶向栈底只能在链表头部进行操作故链表没有必要像单链表那样附加头结点栈顶指针就是链表的头指针无栈满问题但存在栈空约束链式栈的创建压栈创建一个新节点并使其域赋值弹栈栈为空不能执行出栈操作两者比较利用栈来消除递归简单的递归转换阶乘递归实现阶乘非递归实现尾递归指函数的最后一个动作时调用函数本身的递归函数是递归的一种特殊情形尾递归的本质是将单词计算的结果缓存起来传递给下次调用相当于自动累积尾递归递归调用直接返回机械的递归转换方法步骤设置一工作栈保存当前工作记录设置个语句标志增加非递归入口替换第个递归规则所有递归出口处增加语句标号为的语句的格式改写循环和嵌套中的递归优化处理简化的背包问题我们有件物品物品的重量为如果限定每种物品要么完全放进背包要么不放进背包即物品是不可分割的问能否从这件物品中选择若干件放入背包使其重量之和恰好为我们来看递归版本递归关系当当或且当且两种情况是否取最后一项设置一工作栈保存当前工作记录在函数中出现的所有参数和局部变量都必须用栈中的数据成员代替返回情况标号函数参数值参引用型局部变量对应三种情况背包容量和物品数目返回情况标号结果单元设置个语句标号第一个可执行语句设置在函数题结束处第个递归返回处增加非递归入口将第一个数据成员递归起点压入栈替换第个递归规则所有递归出口处增加语句递归出口增加跳转语句以进行递归结束后的相关处理标号为的语句标号为的语句形如改写循环和嵌套中的递归结果对应三种情况背包容量和物品数目返回情况标号结果单元将第一个数据成员递归起点压入栈没有满足出口条件查看栈顶并分情况处理输出物品某层结果单元为回溯结果单元上传给调用层算法结束合法出栈序列给定一个入栈序列类型要求输出一个类型中存储着的所有合法出栈序列如果所有元素都已处理且栈为空则当前序列是一个合法的出栈序列如果还有元素未入栈可以选择入栈选择入栈回溯撤销入栈操作如果栈不为空可以选择出栈回溯撤销出栈操作恢复栈状态示例使用所有合法的出栈序列为给定一个入栈序列一个出栈序列写一个程序判断出栈序列是否合法生成函数声明请输入序列的长度请输入入栈序列用空格分隔请输入出栈序列用空格分隔检查输入序列是否包含相同的元素入栈序列和出栈序列的元素不一致无法比较出栈序列是合法的出栈序列是不合法的将当前入栈元素压入栈中检查栈顶元素是否与当前出栈元素匹配如果所有出栈元素都匹配完且栈为空则合法给定一个入栈序列序列长度为请计算由多少种出栈序列卡特兰数其表示从到不穿过对角线的路径数那么我们可以将栈的出栈序列这样抽象化我们知道在栈未完全弹出前出栈的次数一定小于等于入栈的次数我们将入栈看做到出栈看做到每一个路径都对应于一个出栈序列那么我们可以知道该路径肯定不会穿过对角线因为栈的次数一定小于等于入栈的次数则出栈序列个数就是卡特兰数队列队列的循环队列实现入队出队判断队满判断队空链式队列作业题证明必要性若输出序列可由栈操作得到则不存在使得假设输出序列可以通过栈操作得到我们要证明在该序列中不存在下标使得假设反设存在使得考虑栈操作过程中的这三个元素元素的出栈在位置元素被弹出栈这意味着在此之前元素到已经被压入栈或弹出元素的出栈在位置元素被弹出栈由于在之后被弹出且因此必须在被弹出后仍留在栈中这意味着在之前被压入栈但在被弹出后才被弹出元素的出栈在位置元素被弹出栈由于介于和之间且这意味着在被弹出后被压入栈并在被弹出前被弹出然而这与栈的后进先出性质矛盾因为在之前被压入栈但在之后被弹出这不符合栈的操作规则因此假设不成立输出序列中不存在这样的充分性若输出序列中不存在使得则可以通过栈操作得到该序列我们将构造一个栈操作序列使得输入序列可以通过栈操作得到输出序列算法步骤初始化设栈为空输入指针指向输出指针指向循环操作步骤若栈顶元素等于当前输出指针指向的元素则弹出栈顶元素并将输出指针移动到下一个元素步骤否则若输入指针未超过则将输入指针指向的元素压入栈并将输入指针移动到下一个元素步骤若输入指针已超过但栈顶元素不等于则算法失败无法生成输出序列结束条件当输出指针超过时算法成功证明算法的正确性栈的单调性在任何时刻栈中的元素都是严格递减的这是因为只有当栈顶元素等于当前需要输出的元素时才会弹出否则只会压入更大的元素避免的情况由于序列中不存在且所以在上述算法中不会遇到无法弹出栈顶元素且无法继续压栈的矛盾情况因此该算法能够成功地将输入序列通过栈操作得到输出序列结论从初始输入序列可以利用一个栈得到输出序列的充分必要条件是输出序列中不存在下标使得第章字符串一概念串模式匹配二方法串的基本操作串的存储及运算串的快速模式匹配算法求特征向量数组数组和利用向量完成匹配的方法注意变种算法的特征定义特征向量和算法在字符串相关问题中的灵活应用串的快速模式匹配算法非优化的算法就是简单的最大的公共前后缀的长度为模板的长度动态存储区开辟整数数组如果那么我们把前面已经分析过一直循环直到条件不满足递归地向前找找到相等的了即了那么了当时考虑我们在比较和时既然已经和不匹配了我们回溯到还是不匹配地不如直接回溯到因此回溯算法是模式匹配算法的模式的下标变量目标的下标变量模式的长度目标的长度若目标比模式段匹配无法成功反复比较对应字符来开始匹配算法复杂度分析先看求的数组的复杂度我们注意到在循环中只增不减因此时间复杂度为对于匹配我们又注意到在循环中只增不减因此算法的时间复杂度是第章二叉树一概念二叉树二叉树的深度优先遍历二叉搜索树堆树编码二方法二叉树的链式存储二叉链表带父指针的三重链表二叉树的顺序存储完全二叉树的顺序存储二叉树的深度优先遍历要求自己能用递归解决二叉树应用问题看得懂非递归二叉树遍历框架可以完成采用非递归算法设计的算法填空二叉树的广度优先遍历及其应用二叉搜索树的插入与删除构造树利用树进行编码解码堆的建立与维护过程思考题部分题在手写笔记上个节点的二叉树有多少种不同的形态是一个数即考虑其递归即可定义满二叉树如果一棵二叉树的结点或为树叶度节点或为两颗非空子树度节点则称作满二叉树完全二叉树完全二叉树的特点叶节点只可能在最下面两层出现路径长度和最短满二叉树不具有此性质扩充二叉树重要性质二叉树的周游放这的时候是前序递归访问左子树放这的时候是中序递归访问右子树后序引入输入输出流库引入向量库使用标准命名空间声明一个全局向量用于存储结果深度优先搜索函数接受中序遍历和后序遍历的向量如果中序数组的大小为说明没有节点直接返回如果中序数组的大小为说明只有一个节点将该节点添加到结果中将后序数组的最后一个元素作为根节点添加到结果中根节点用于存储根节点在中序数组中的位置遍历中序数组找到根节点的位置找到位置记录下来切分中序数组为左子树和右子树左子树右子树切分后序数组为左子树和右子树左子树右子树递归处理左子树递归处理右子树返回声明一个向量用于存储输入的数字定义一个整型变量用于接收输入从标准输入中读取数字直到输入结束将输入的数字添加到向量中声明一个向量用于存储中序数组声明一个向量用于存储后序数组将数组的前一半添加到数组中将前一半的元素添加到中将数组的后一半添加到数组中将后一半的元素添加到中调用深度优先搜索函数输出中的数每两个之间有空格分隔输出数组的元素非递归深度优先遍历前序遍历非递归算法定义树节点结构前序遍历函数用于存储遍历结果如果树为空返回空向量访问当前节点先压入右子节点后压入左子节点确保左子节点先被处理返回遍历结果辅助函数创建示例树辅助函数释放树的内存防止内存泄漏创建示例树执行前序遍历打印遍历结果前序遍历结果释放分配的内存非递归中序遍历二叉树算法定义树节点结构中序遍历函数用于存储遍历结果辅助栈当前节点指针一直向左子树遍历并将沿途节点压入栈中当没有左子节点时弹出栈顶节点访问该节点访问当前节点转向右子节点继续遍历返回遍历结果辅助函数创建示例树辅助函数释放树的内存防止内存泄漏创建示例树执行中序遍历打印遍历结果中序遍历结果释放分配的内存非递归后序遍历二叉树定义树节点结构后序遍历函数用于存储遍历结果返回遍历结果辅助函数创建示例树辅助函数释放树的内存防止内存泄漏创建示例树执行后序遍历打印遍历结果后序遍历结果释放分配的内存广度优先遍历二叉树二叉搜索树的插入和删除二叉搜索树二叉排序树或者是一颗空树或者是具有下列性质的二叉树对于任何一个节点设其值为则该节点的左子树若不空的任意一个值都小于该节点的右子树若不空的任意一个节点的值都大于而且它的左右子树也分别为二叉搜索树二叉搜索树的插入思想定义树节点结构删除未优化改进替换结点替换结点的父结点待删除结点父结点若待删除结点的左子树为空就将其右子树代替它待删除结点左子树不空在左子树中寻找最大结点替换待删除结点替换结点就是被删除结点的左子结点左子树挂接为其父被删结点的左子树替换结点的左子树挂接为其父的右子树继承待删除结点左子树继承待删除结点右子树用替换结点去替代真正的删除结点删除该结点堆的建立和维护是完全二叉树包含输入输出流库包含向量库使用标准命名空间定义模板类支持任意类型指向堆数组的指针当前堆中元素的个数堆的最大容量用于构建堆的私有方法私有交换函数用于交换堆中的元素用临时变量存储第个元素将第个元素赋值给第个元素将临时变量的值赋回到第个元素构造函数接受元素个数和数组如果元素个数小于等于直接返回设置当前大小为设置堆的最大容量动态分配堆数组将输入数组元素复制到堆数组中赋值构建堆析构函数释放堆数组内存获取左子节点的索引左子节点的位置获取右子节点的索引右子节点的位置获取父节点的索引父节点的位置向下筛选函数当前节点的位置左子节点的位置保存当前节点的值当左子节点在堆的有效范围内如果右子节点存在且小于左子节点更新为右子节点如果当前节点值大于子节点值将子节点值上移更新当前节点为子节点更新为新的左子节点位置如果当前节点值不大于子节点值结束循环将保存的当前值放入正确的位置向上筛选函数当前节点位置保存当前节点的值将父节点上移更新当前节点位置为父节点将保存的值放回到正确的位置插入新节点如果当前大小等于最大容量返回将新节点添加到堆的末尾向上筛选以保持堆的性质更新当前堆大小插入成功返回删除堆中最小值从堆顶删除最小值如果堆为空输出不能删除的提示退出程序保存当前堆顶的最小值将最后一个元素放到堆顶并减少当前大小如果堆中还有多个元素从堆顶开始向下筛选返回删除的最小值根据位置删除指定节点如果位置无效返回保存要删除的节点值将最后一个元素放到删除的位置并减少当前大小向上筛选向下筛选删除成功返回用于构建堆的私有方法的实现从最后一个非叶子节点开始向前遍历所有节点对当前节点执行向下筛选操作构造树利用树进行编码解码定义具有最小带权路径长度的二叉树称作哈夫曼树或称最优二叉树建立编码树的过程编码过程译码第章树一概念树森林树的先根遍历后根遍历层次遍历叉树二方法森林与二叉树相互转换森林的链式存储转换为相应的二叉树用二叉链表示父指针表示法子结点表表示法等价类和并查算法的应用森林的深度优先遍历递归可能结合应用森林的层次遍历用队列可能结合应用森林二叉树的顺序存储不必死记各种顺序存储方法要了解原理其本质是按照遍历的性质把内存中森林二叉树输出一个顺序存储的序列反过来也可以根据相应的顺序存储的序列构造内存中的森林二叉树森林和二叉树的相互转换森林转换成二叉树检查森林是否为空如果为空返回空指针二叉树根节点初始化为空当前节点初始化为空遍历森林中的每棵树如果二叉树根节点为空将当前树转换为二叉树根节点当前节点设为二叉树根节点如果二叉树根节点不为空将当前树转换为右节点移动到下一个右节点返回生成的二叉树根节点树换成二叉树树转换为二叉树检查树根节点是否为空如果为空返回空指针创建一个二叉树根节点值与树根节点相同如果有子节点将第一个子节点转换为二叉树左子树当前节点设为左子节点遍历剩下的子节点将子节点转换为右子树移动到下一个右节点返回生成的二叉树根节点二叉树转换成森林二叉树转换为森林创建一个森林树的集合检查根节点是否为空如果为空返回空森林当前节点设为根节点遍历右兄弟节点将右兄弟节点转换为树并添加到森林移动到下一个右节点将根节点转换为树并添加到森林返回生成的森林二叉树为树二叉树转换为树检查根节点是否为空如果为空返回空指针创建一个树的根节点值与二叉树根节点相同处理左子树转换为孩子如果左子节点存在将左子树转换为树节点并添加为孩子当前节点设为左子节点遍历右兄弟节点将右兄弟节点转换为树节点并添加为孩子移动到下一个右节点返回生成的树节点树的周游树的链式存储这种方法本质是将树转化成二叉树再存储该二叉树的二叉链的表示树的抽象数据类型的实现引入输入输出流库引入向量库引入队列库使用标准命名空间定义一个模板类节点的值左孩子指针右兄弟指针构造函数用于初始化节点值并将孩子和兄弟指针设置为空初始化左孩子为初始化右兄弟为判断当前节点是否是叶子节点没有孩子如果左孩子为返回在当前节点的孩子位置插入一个新的节点如果当前节点有孩子新节点的兄弟指向当前的第一个孩子将新节点插入为第一个孩子如果当前节点没有孩子直接将新节点作为孩子定义一个模板类树的根节点查找当前节点的父节点创建一个队列用于层次遍历从根节点开始遍历记录上一个节点如果当前节点为空或是根节点返回表示没有父节点遍历整个树如果当前节点是树的根节点直接返回将当前节点加入队列移动到下一个兄弟节点队列不为空时遍历队列找到当前节点的父节点取队列头部元素弹出队列头部元素移动到当前节点的孩子对孩子进行遍历找到当前节点返回当前节点的父节点将孩子节点加入队列移动到下一个兄弟节点查找当前节点的前驱兄弟节点找到当前节点的父节点用于存储父节点的孩子如果找到父节点获取父节点的第一个孩子如果没有父节点将指向根节点如果当前节点是第一个子节点返回返回表明没有前驱兄弟遍历兄弟节点寻找前驱兄弟如果兄弟节点是当前节点的前驱返回前驱兄弟节点移动至下一个兄弟节点没有找到前驱兄弟节点返回销毁所有节点如果节点为空直接返回递归销毁孩子节点递归销毁兄弟节点删除当前节点删除一个子树找到子树根节点的前驱兄弟如果没有前驱兄弟找到父节点如果找到父节点让父节点的孩子指向子树的下一个兄弟断开子树根与兄弟的连接如果没有父节点意味着要删除的是根的子树更新根节点为子树的下一个兄弟断开子树根与兄弟的连接如果找到了前驱兄弟让前驱兄弟指向子树的下一个兄弟断开子树根与兄弟的连接销毁子树父指针表示法及在并查集中的应用并查集并查集是一种特殊集合由不相交子集构成基本操作判断两个节点是否在同一个集合中归并两个集合并查集可用于求解等价类问题引入输入输出流库用于读取输入和输出结果引入向量库用于创建和管理动态数组使用标准命名空间定义类表示树的节点节点的值指向父节点的指针初始为空子节点数量计数器初始为设置父节点将当前节点的父节点设置为设置子节点数量将子节点数量设置为带参数的构造函数用于初始化节点值默认构造函数定义类表示树数据结构存储树节点的动态数组树的大小用于保存结果带参数的构造函数初始化树的大小和结果初始化树节点逐个创建节点并存入数组中查找节点的根节点使用路径压缩如果当前节点没有父节点则返回该节点递归查找父节点并进行路径压缩返回节点的父节点合并两个节点的集合查找第个节点的根查找第个节点的根如果两个节点不在同一个集合中合并操作保持树的平衡将的根设置为更新的子节点数量将的根设置为更新的子节点数量合并后结果减少一个集合检查两个节点是否在不同的集合中查找第个节点的根查找第个节点的根返回是否在不同集合中主函数定义和分别表示节点数和边数案例编号初始为循环读取输入如果输入为则退出循环创建一个对象初始化节点数和结果循环读取边的连接关系定义两个节点读取节点和合并这两个节点的集合输出当前案例的结果打印连接组件的数量案例编号自增树的顺序存储方法本质是按照树遍历的次序进行节点存储带右链的先根次序表示法先转换成二叉树再搞带双标记位的先根次序表示法双标记位先根次序树结点类树结点信息存储节点的数据左标记用于表示左子树的存在情况右标记用于表示右兄弟的存在情况默认构造函数虚析构函数初始化左标记为表示左子树存在初始化右标记为表示右兄弟存在析构函数定义当前未进行任何操作这是构造左子结点右兄弟树的算法使用标准库中的栈创建一个栈用于存储树节点指针创建一个新的树结点指针将根节点指针指向新的结点遍历节点数组构建树设置当前节点的值如果有右兄弟将当前指针压入栈中如果没有右兄弟设置当前指针的兄弟域为空创建一个临时指针用于下一个节点如果有孩子设置当前指针的孩子为临时指针如果没有孩子设置孩子域为空从栈中弹出一个指针将弹出的指针的兄弟域设置为临时指针更新当前指针为临时指针处理最后一个节点设置最后一个节点的值设定最后一个节点的孩子为空设定最后一个节点的兄弟为空带度数的后根次序表示法带双标记的层次次序表示导入输入输出流库导入队列库导入向量库模板类表示一棵树其中是节点存储的数据类型根节点指针默认构造函数初始化树的根节点为析构函数调用清除函数释放树的节点构造函数根据双标记的层次次序序列构建树如果节点数组为空则树的根节点为队列用于层次遍历构建树创建一个迭代器用于遍历节点数组创建根节点并将其信息赋值检查根节点是否有左孩子如果根节点有孩子则将根节点入队移动到下一个节点遍历以构建树直到迭代器达到数组末尾如果队列为空说明树结构不合法输出错误信息退出循环获取当前节点处理当前节点的孩子创建孩子节点将孩子节点与当前节点关联检查孩子节点是否有左孩子如果有左孩子将其入队检查孩子节点是否有右兄弟如果有右兄弟继续处理兄弟节点记录当前孩子节点作为前一个兄弟移动到下一个节点遍历兄弟节点检查前一个兄弟是否已有右兄弟当前节点已经有兄弟不继续创建兄弟节点将兄弟节点关联到前一个兄弟上检查兄弟节点是否有左孩子如果有左孩子将其入队检查兄弟节点是否没有更多兄弟结束兄弟处理更新前一个兄弟为当前兄弟移动到下一个节点如果没有右兄弟直接移动到下一个节点检查是否达到节点数组末尾结束构建如果当前节点没有更多孩子出队当前节点出队递归释放树的节点如果节点不为空继续递归清除先清除孩子节点然后清除兄弟节点删除当前节点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-14 11:19:49',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="C+V" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://pku-cs-cjw.top/image/加载.gif"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/187370" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/YuanQiPKU/Reservoir" title="账目管理"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="账目管理"/><span class="back-menu-item-text">账目管理</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">C+V</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/%E8%AE%A2%E9%98%85%E6%88%91%E5%90%A7"><span> 订阅我吧</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about-this-wed"><span> 关于此站</span></a></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://pku-cs-cjw.top/image/微信.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://pku-cs-cjw.top/image/微信.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://pku-cs-cjw.top/image/支付宝.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://pku-cs-cjw.top/image/支付宝.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSAPP/" style="font-size: 1.05rem;">CSAPP<sup>3</sup></a><a href="/tags/ICS/" style="font-size: 1.05rem;">ICS<sup>1</sup></a><a href="/tags/ics/" style="font-size: 1.05rem;">ics<sup>2</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/" style="font-size: 1.05rem;">数据结构与算法A<sup>3</sup></a><a href="/tags/%E6%95%B0%E7%AE%97/" style="font-size: 1.05rem;">数算<sup>1</sup></a><a href="/tags/%E6%B0%B4%E6%96%87/" style="font-size: 1.05rem;">水文<sup>2</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>6</sup></a><a href="/tags/%E9%B8%A1%E6%B1%A4/" style="font-size: 1.05rem;">鸡汤<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据结构与算法A</span></a></span></div></div><h1 class="post-title" itemprop="name headline">数算复习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-11-06T03:32:32.000Z" title="发表于 2024-11-06 11:32:32">2024-11-06</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-11-14T03:19:49.424Z" title="更新于 2024-11-14 11:19:49">2024-11-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="leancloud_visitors" id="/posts/147acb51/" data-flag-title="数算复习笔记"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span class="leancloud-visitors-count" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/147acb51/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/147acb51/" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://pku-cs-cjw.top/posts/147acb51/"><header><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/" tabindex="-1" itemprop="url">数据结构与算法A</a><h1 id="CrawlerTitle" itemprop="name headline">数算复习笔记</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">C+V</span><time itemprop="dateCreated datePublished" datetime="2024-11-06T03:32:32.000Z" title="发表于 2024-11-06 11:32:32">2024-11-06</time><time itemprop="dateCreated datePublished" datetime="2024-11-14T03:19:49.424Z" title="更新于 2024-11-14 11:19:49">2024-11-14</time></header><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><p>由于本篇过大，hexo架构渲染时有点问题，这里有pdf版本</p>
<div calss='anzhiyu-tag-link'><a class="tag-Link" target="_blank" href="https://pku-cs-cjw.top/数算期中复习.pdf">
    <div class="tag-link-tips">引用站外地址</div>
    <div class="tag-link-bottom">
        <div class="tag-link-left" style="background-image: url(https://img.picui.cn/free/2024/09/20/66ed060ab82d2.jpg)">
          <i class="anzhiyufont anzhiyu-icon-link" style="display: none"></i>
        </div>
        <div class="tag-link-right">
            <div class="tag-link-title">pdf版本</div>
            <div class="tag-link-sitename"> 有点多</div>
        </div>
        <i class="anzhiyufont anzhiyu-icon-angle-right"></i>
    </div>
    </a></div>

<h2 id="3-考试范围和重点"><a href="#3-考试范围和重点" class="headerlink" title="3. 考试范围和重点"></a>3. 考试范围和重点</h2><p>1-6章，以本文最后的内容为复习重点，尤其是★标出部分为重中之重。考试时如果涉及到本大纲没有列出的内容，那么试卷中会给出足够的定义和性质。</p>
<h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023111238323.png" class="" title="image-20241023111238323">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241027102017356.png" class="" title="image-20241027102017356">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241027102924655.png" class="" title="image-20241027102924655">



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241027102935632.png" class="" title="image-20241027102935632">









<h1 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章 概论"></a>第1章 概论</h1><p>一. 重要概念</p>
<ol>
<li>抽象数据结构 2. 数据逻辑结构 3.数据存储结构 4. 算法 ★ 5. 算法分析(时间代价、空间代价) 6. 数据结构的选择和评价</li>
</ol>
<p>二. 方法</p>
<ol>
<li>根据二元组画出图示逻辑结构(注意边的方向)</li>
</ol>
<p> ★ 2. 根据要求设计数据结构<br> ★ 3. 算法的渐进分析方法<br> ★ 4.算法分析的大O表示法（不要求掌握大Ω、大Θ表示法）</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>涉及数据之间的<strong>逻辑关系</strong>，数据在计算机中的<strong>存储表示</strong>和在这种结构上的一组能执行的<strong>操作（运算）</strong>三个方面</li>
<li>三要素<ul>
<li>逻辑结构</li>
<li>存储（物理）结构</li>
<li>运算</li>
</ul>
</li>
</ul>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>具体问题的数学抽象，反映事物的组成和逻辑关系</p>
<p>逻辑结构的表示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022125329901.png" class="" title="image-20241022125329901">

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022125944406.png" class="" title="image-20241022125944406">



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022130602048.png" class="" title="image-20241022130602048">

<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>抽象数据类型由&lt;数据对象、数据关系、数据操作&gt;</p>
<p>三个不可分割的部分组成的三元组</p>
<p>ADT抽象数据类型名{</p>
<p>数据对象D：&lt;数据对象的定义&gt;</p>
<p>数据关系S： &lt;数据关系的定义&gt;</p>
<p>数据操作P：&lt;基本操作的定义&gt;</p>
<p>}ADT抽象数据类型名</p>
<h2 id="算法分析"><a href="#算法分析" class="headerlink" title="&#x3D;&#x3D;算法分析&#x3D;&#x3D;"></a>&#x3D;&#x3D;算法分析&#x3D;&#x3D;</h2><ul>
<li>算法分析是对一个算法需要多少计算时间和存储时间作定量的分析</li>
<li>判断所提出的算法&#x3D;&#x3D;是否符合现实情况&#x3D;&#x3D;</li>
<li>时间和空间复杂性</li>
</ul>
<h3 id="算法的渐进分析"><a href="#算法的渐进分析" class="headerlink" title="&#x3D;&#x3D;算法的渐进分析&#x3D;&#x3D;"></a>&#x3D;&#x3D;算法的渐进分析&#x3D;&#x3D;</h3><p>$$<br>f(n)&#x3D;n^2+100n+log_{10}n+1000<br>$$</p>
<ul>
<li>算法分析：估计当数据规模n逐步增大时，（时间或者空间）资源开销f(n)的增长规模</li>
<li>从数量级大小的比较来考虑，当n增大到一定值时，资源开销的计算公式中影响最大的就是n的幂次最高的项，其他的常数项和低幂次项均可忽略不计</li>
</ul>
<h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="&#x3D;&#x3D;大O表示法&#x3D;&#x3D;"></a>&#x3D;&#x3D;大O表示法&#x3D;&#x3D;</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022133255598.png" class="" title="image-20241022133255598">

<h3 id="二分查找法时间复杂度推导"><a href="#二分查找法时间复杂度推导" class="headerlink" title="二分查找法时间复杂度推导"></a>二分查找法时间复杂度推导</h3><p>二分查找法（Binary Search）是一种高效的查找算法，适用于<strong>已排序</strong>的数组或列表。它通过反复将查找范围缩小一半来快速定位目标元素。其时间复杂度为 ( O(\log n) )。下面将详细推导二分查找法的时间复杂度。</p>
<h4 id="一、二分查找法的基本原理"><a href="#一、二分查找法的基本原理" class="headerlink" title="一、二分查找法的基本原理"></a>一、二分查找法的基本原理</h4><p>假设有一个<strong>升序</strong>排列的数组 ( A ) ，包含 ( n ) 个元素。目标是查找某个特定的元素 ( x ) 是否存在于数组中，并找到其位置。二分查找的步骤如下：</p>
<ol>
<li><strong>确定查找范围</strong>：初始时，查找范围为整个数组，即从下标 ($$ \text{low} &#x3D; 0$$ ) 到 ($$ \text{high} &#x3D; n-1$$ )。</li>
<li><strong>找到中间元素</strong>：计算中间下标</li>
</ol>
<p>$$<br>\text{mid} &#x3D; \left\lfloor \frac{\text{low} + \text{high}}{2} \right\rfloor<br>$$</p>
<p>然后比较 ( $$A[\text{mid}]$$ ) 与 ( x )：</p>
<ul>
<li>如果 ( $$A[\text{mid}] &#x3D; x )，查找成功，返回 ( \text{mid} )$$。</li>
<li>如果 ( $$A[\text{mid}] &lt; x $$)，则目标元素 ( x ) 只能在右半部分，即更新查找范围为 ( $$\text{low} &#x3D; \text{mid} + 1$$ ) 到 ($$ \text{high}$$ )。</li>
<li>如果 ( $$A[\text{mid}] &gt; x$$ )，则目标元素 ( x ) 只能在左半部分，即更新查找范围为 ( $$\text{low} $$) 到 ( $$\text{mid} - 1$$ )。</li>
</ul>
<ol start="3">
<li><strong>重复步骤2</strong>，直到找到目标元素或查找范围为空。</li>
</ol>
<h4 id="二、时间复杂度的推导"><a href="#二、时间复杂度的推导" class="headerlink" title="二、时间复杂度的推导"></a>二、时间复杂度的推导</h4><h5 id="1-每一步缩小查找范围的大小"><a href="#1-每一步缩小查找范围的大小" class="headerlink" title="1. 每一步缩小查找范围的大小"></a>1. 每一步缩小查找范围的大小</h5><p>在每一步操作中，二分查找法将当前的查找范围缩小一半。这意味着：</p>
<ul>
<li>初始时，查找范围大小为 ( n )。</li>
<li>第一次比较后，查找范围缩小到</li>
</ul>
<p>$$<br>\frac{n}{2}<br>$$</p>
<ul>
<li>第二次比较后，查找范围缩小到</li>
</ul>
<p>$$<br>\frac{n}{4}<br>$$</p>
<ul>
<li>第 ( k ) 次比较后，查找范围缩小到</li>
</ul>
<p>$$<br>\frac{n}{2^k}<br>$$</p>
<h5 id="2-确定最坏情况下需要的比较次数"><a href="#2-确定最坏情况下需要的比较次数" class="headerlink" title="2. 确定最坏情况下需要的比较次数"></a>2. 确定最坏情况下需要的比较次数</h5><p>最坏情况下，二分查找需要继续缩小查找范围，直到查找范围大小为1，即：</p>
<p>$$<br>\frac{n}{2^k} \leq 1<br>$$</p>
<p>解这个不等式：</p>
<p>$$<br>n \leq 2^k \<br>\Rightarrow \log_2 n \leq k<br>$$</p>
<p>因此，最坏情况下需要的比较次数 ( k ) 至少为 </p>
<p>$$<br>\log_2 n<br>$$</p>
<h5 id="3-递归关系的推导"><a href="#3-递归关系的推导" class="headerlink" title="3. 递归关系的推导"></a>3. 递归关系的推导</h5><p>可以通过递归关系进一步确认时间复杂度。</p>
<p>设 ( T(n) ) 为在大小为 ( n ) 的数组上进行二分查找的时间复杂度。根据二分查找的步骤，每次比较后将问题规模缩小一半，并进行常数时间的比较操作。因此递归关系为：</p>
<p>$$<br>T(n) &#x3D; T\left(\frac{n}{2}\right) + c<br>$$</p>
<p>其中，( c ) 是常数时间（比较操作）的时间。</p>
<p>通过递归展开：</p>
<p>$$<br>T(n) &#x3D; T\left(\frac{n}{2}\right) + c \<br>&#x3D; T\left(\frac{n}{4}\right) + 2c \<br>&#x3D; T\left(\frac{n}{8}\right) + 3c \<br>\vdots \<br>&#x3D; T\left(\frac{n}{2^k}\right) + kc<br>$$</p>
<p>当 </p>
<p>$$<br>\frac{n}{2^k} &#x3D; 1<br>$$</p>
<p>即 ( k &#x3D; \log_2 n ) 时，递归终止：</p>
<p>$$<br>T(n) &#x3D; T(1) + c \log_2 n<br>$$</p>
<p>由于 ( T(1) ) 是常数，最终时间复杂度为：</p>
<p>$$<br>T(n) &#x3D; O(\log n)<br>$$</p>
<h5 id="4-示例说明"><a href="#4-示例说明" class="headerlink" title="4. 示例说明"></a>4. 示例说明</h5><p>假设有一个大小为 ( n &#x3D; 16 ) 的数组，进行二分查找的步骤如下：</p>
<ol>
<li><strong>第一次比较</strong>：查找范围 ( 16 ) 个元素，比较中间的第 ( 8 ) 个元素。</li>
<li><strong>第二次比较</strong>：查找范围缩小到 ( 8 ) 个元素，比较中间的第 ( 4 ) 个元素。</li>
<li><strong>第三次比较</strong>：查找范围缩小到 ( 4 ) 个元素，比较中间的第 ( 2 ) 个元素。</li>
<li><strong>第四次比较</strong>：查找范围缩小到 ( 2 ) 个元素，比较中间的第 ( 1 ) 个元素。</li>
<li><strong>第五次比较</strong>：查找范围缩小到 ( 1 ) 个元素，比较最终元素。</li>
</ol>
<p>可以看到，比较次数为 </p>
<p>$$<br>\log_2 16 &#x3D; 4<br>$$</p>
<p>对于一般情况，大小为 ( n ) 的数组，最多需要 </p>
<p>$$<br>\log_2 n<br>$$</p>
<p>次比较。</p>
<h4 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h4><p>二分查找法通过每次将查找范围缩小一半，使得其时间复杂度为对数级别，即 </p>
<p>$$<br>O(\log n)<br>$$</p>
<p>这种高效的查找性能使得二分查找在处理大规模已排序数据时非常有用。</p>
<h1 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h1><p>一. 概念</p>
<ol>
<li>线性表 2. 单链表 3. 双链表 4. 循环表</li>
</ol>
<p>二. 方法</p>
<ol>
<li>顺序表上实现的运算</li>
</ol>
<p> ★ 2.链表上实现的运算(指针操作的正确性) </p>
<ol start="3">
<li>顺序表和链表的比较</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>&#x3D;&#x3D;插入和删除要注意边界&#x3D;&#x3D;</p>
<p>链表检索</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022143153914.png" class="" title="image-20241022143153914">



<p><strong>链表插入</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNode* <span class="title function_">Insert</span><span class="params">(<span class="type">int</span> i,T value)</span>&#123;</span><br><span class="line">    ListNode *p,*q;</span><br><span class="line">    q=new ListNode;</span><br><span class="line">    p=setPos(i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    q-&gt;data=value;</span><br><span class="line">    q-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=q;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        tail=q;</span><br><span class="line">   	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>链表删除</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="type">bool</span> lnkList&lt;T&gt;::delete(<span class="type">const</span> <span class="type">int</span> i)&#123;</span><br><span class="line">    Link&lt;T&gt;*p,*d;</span><br><span class="line">    <span class="keyword">if</span>((p=setPos(i<span class="number">-1</span>))==<span class="literal">NULL</span>||p==tail)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;非法删除点&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(d=tail)&#123;</span><br><span class="line">        tail=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        delete d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p-&gt;next=d-&gt;next;</span><br><span class="line">        delete d;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性表实现方法的比较"><a href="#线性表实现方法的比较" class="headerlink" title="线性表实现方法的比较"></a>线性表实现方法的比较</h2><ul>
<li>顺序表的主要优点<ul>
<li>没有使用指针，不用花费额外开销</li>
<li>线性表元素的访问非常便利</li>
</ul>
</li>
<li>链表的主要优点<ul>
<li>无需事先了解线性表的长度‘</li>
<li>允许线性表的长度动态变化</li>
<li>能够适应经常插入删除内部元素的情况</li>
</ul>
</li>
<li>顺序表适合存储静态数据，链表适合动态数据</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022193432198.png" class="" title="image-20241022193432198">

<h1 id="第3章-栈与队列"><a href="#第3章-栈与队列" class="headerlink" title="第3章 栈与队列"></a>第3章 栈与队列</h1><p>一. 概念</p>
<ol>
<li>栈 2. 队列 3. 循环队列</li>
</ol>
<p>二. 方法</p>
<p>★ 1. 栈的性质，用栈来生成序列，栈的实现</p>
<ol start="2">
<li>队列的性质，用队列生成序列</li>
</ol>
<p> ★3. 循环队列的实现<br> ★ 4. <strong>利用栈来消除递归</strong></p>
<ol start="5">
<li>栈的灵活应用，例如表达式求值 (中缀表达式转后缀表达式的算法、后缀表达式求值算法)</li>
</ol>
<h2 id="栈的性质"><a href="#栈的性质" class="headerlink" title="&#x3D;&#x3D;栈的性质&#x3D;&#x3D;"></a>&#x3D;&#x3D;栈的性质&#x3D;&#x3D;</h2><ul>
<li>先进后出</li>
</ul>
<h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="&#x3D;&#x3D;栈的实现&#x3D;&#x3D;"></a>&#x3D;&#x3D;栈的实现&#x3D;&#x3D;</h3><h3 id="栈的ADT"><a href="#栈的ADT" class="headerlink" title="栈的ADT"></a>栈的ADT</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="comment">// 栈的元素类型为 T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 栈的运算集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;  <span class="comment">// 变为空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T item)</span></span>;  <span class="comment">// item入栈, 成功则返回真, 否则返回假</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>;  <span class="comment">// 返回栈顶内容并弹出, 成功返回真, 否则返回假</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">top</span><span class="params">(T &amp;item)</span></span>;  <span class="comment">// 返回栈顶内容但不弹出, 成功返回真, 否则返回假</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;  <span class="comment">// 若栈已空返回真</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span></span>;  <span class="comment">// 若栈已满返回真</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022202329113.png" class="" title="image-20241022202329113">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022202550490.png" class="" title="image-20241022202550490">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022202938263.png" class="" title="image-20241022202938263">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022203036483.png" class="" title="image-20241022203036483">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022203048362.png" class="" title="image-20241022203048362">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022203112401.png" class="" title="image-20241022203112401">





<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><ul>
<li>上溢(overflow)<ul>
<li>当栈中已经有maxsize个元素时，如果再做进栈操作，所产生的”无空间可用”现象</li>
</ul>
</li>
<li>下溢（underflow）<ul>
<li>空栈进行出栈所产生的“无元素可删”现象</li>
</ul>
</li>
</ul>
<h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><ul>
<li>栈的链式存储结构，是运算受限的链表</li>
<li>指针方向：&#x3D;&#x3D;从栈顶向栈底&#x3D;&#x3D;</li>
<li>只能在链表头部进行操作，&#x3D;&#x3D;故链表没有必要像单链表那样附加头结点。&#x3D;&#x3D;</li>
<li>栈顶指针就是链表的头指针（top）</li>
<li>无栈满问题（但存在栈空约束）</li>
</ul>
<h4 id="链式栈的创建"><a href="#链式栈的创建" class="headerlink" title="链式栈的创建"></a>链式栈的创建</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022204704284.png" class="" title="image-20241022204704284">



<p>压栈</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022205744421.png" class="" title="image-20241022205744421">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> InkStack&lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T item)&#123;</span><br><span class="line">    <span class="comment">//创建一个新节点，并使其next域赋值top</span></span><br><span class="line">    Link&lt;T&gt;* tmp=<span class="keyword">new</span> <span class="built_in">Link</span>&lt;T&gt;(item,top)</span><br><span class="line">    top = tmp;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弹栈</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> InkStack&lt;T&gt;::<span class="built_in">pop</span>(T&amp; item)&#123;</span><br><span class="line">    Link&lt;T&gt;*tmp;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;栈为空，不能执行出栈操作&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    item =top-&gt;data;</span><br><span class="line">    tmp= top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> top;</span><br><span class="line">    top =tmp;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022210011598.png" class="" title="image-20241022210011598">

<h2 id="利用栈来消除递归"><a href="#利用栈来消除递归" class="headerlink" title="&#x3D;&#x3D;利用栈来消除递归&#x3D;&#x3D;"></a>&#x3D;&#x3D;利用栈来消除递归&#x3D;&#x3D;</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022211004153.png" class="" title="image-20241022211004153">



<h4 id="简单的递归转换"><a href="#简单的递归转换" class="headerlink" title="简单的递归转换"></a>简单的递归转换</h4><p>阶乘递归实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>阶乘非递归实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        m=m*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="&#x3D;&#x3D;尾递归&#x3D;&#x3D;"></a>&#x3D;&#x3D;尾递归&#x3D;&#x3D;</h4><ul>
<li>指函数的最后一个动作时调用函数本身的递归函数，是递归的一种特殊情形</li>
<li>尾递归的本质是：将单词计算的结果缓存起来，传递给下次调用，相当于自动累积</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial_tail</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> acc = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">factorial_tail</span>(n - <span class="number">1</span>, n * acc);  <span class="comment">// 尾递归，递归调用直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="机械的递归转换"><a href="#机械的递归转换" class="headerlink" title="&#x3D;&#x3D;机械的递归转换&#x3D;&#x3D;"></a>&#x3D;&#x3D;机械的递归转换&#x3D;&#x3D;</h4><p>方法步骤：</p>
<ul>
<li><p>设置一工作栈保存当前工作记录</p>
</li>
<li><p>设置t+2个语句标志</p>
</li>
<li><p>增加非递归入口</p>
</li>
<li><p>替换第i（i&#x3D;1,…,t）个递归规则</p>
</li>
<li><p>所有递归出口处增加语句:goto label t+1;</p>
</li>
<li><p>标号为t+1的语句的格式</p>
</li>
<li><p>改写循环和嵌套中的递归</p>
</li>
<li><p>优化处理</p>
</li>
<li><p>[简化的0-1背包问题]</p>
</li>
</ul>
<p>​	我们有n件物品，物品i的重量为<code>w[i]</code>。如果限定每种物品：要么完全放进背包，要么不放进背包，即物品是不可分割的。</p>
<p>​	问：能否从这n件物品中选择若干件放入背包，使其重量之和恰好为s</p>
<h5 id="我们来看递归版本"><a href="#我们来看递归版本" class="headerlink" title="我们来看递归版本"></a>我们来看递归版本</h5><p>递归关系<br>$$<br>knap(s,n)&#x3D;\begin{cases}true,当s&#x3D;0\<br>false,当s&lt;0或s&gt;0且n&lt;1\<br>knap(s-w[n-1],n-1)||knap(s,n-1),当s&gt;0且n&gt;&#x3D;1 (两种情况，是否取最后一项)</p>
<p>\end{cases}<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">knap</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s&lt;<span class="number">0</span>||(s&gt;<span class="number">0</span>&amp;&amp;n&lt;<span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">knap</span>(s-w[n<span class="number">-1</span>],n<span class="number">-1</span>))&#123;</span><br><span class="line">        cout&lt;&lt;w[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knap</span>(s,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241022225950275.png" class="" title="image-20241022225950275">

<ul>
<li>1.设置一工作栈保存当前工作记录<ul>
<li>在函数中出现的所有参数和局部变量都必须用栈中的数据成员代替<ul>
<li>返回情况标号</li>
<li>函数参数（值参、引用型）</li>
<li>局部变量</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">rdType</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//对应三种情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">knapNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> s,n;<span class="comment">//背包容量和物品数目</span></span><br><span class="line">    rdType rd;<span class="comment">//返回情况标号</span></span><br><span class="line">    <span class="type">bool</span> k;<span class="comment">//结果单元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>2.设置 t+2个语句标号</p>
<ul>
<li>label 0:第一个可执行语句</li>
<li>label t+1:设置在函数题结束处</li>
<li>label i(1&lt;&#x3D;i&lt;&#x3D;t):第i个递归返回处</li>
</ul>
</li>
<li><p>3.增加非递归入口</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将第一个数据成员（递归起点）压入栈</span></span><br><span class="line">Stack&lt;knapNode&gt;stack;</span><br><span class="line">knapNode tmp;</span><br><span class="line">tmp.s=s;tmp.n=n;tmp.rd=<span class="number">0</span>;</span><br><span class="line">stack.<span class="built_in">push_back</span>(tmp)</span><br></pre></td></tr></table></figure>

<ul>
<li>4.替换第i（i&#x3D;1,…,t）个递归规则</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023082554956.png" class="" title="image-20241023082554956">

<ul>
<li>5.所有递归出口处增加语句<ul>
<li>递归出口增加跳转语句，以进行递归结束后的相关处理<ul>
<li>goto label t+1;</li>
</ul>
</li>
</ul>
</li>
<li>6.标号为t+1的语句<ul>
<li>标号为t+1的语句形如</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack.<span class="built_in">pop</span>(&amp;tmp);</span><br><span class="line"><span class="keyword">switch</span>(tmp.rd)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">goto</span> label1;<span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">case</span> t:<span class="keyword">goto</span> labelt ;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>7.改写循环和嵌套中的递归</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023083105734.png" class="" title="image-20241023083105734">





<ul>
<li>结果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">rdType</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//对应三种情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">knapNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> s,n;<span class="comment">//背包容量和物品数目</span></span><br><span class="line">    rdType rd;<span class="comment">//返回情况标号</span></span><br><span class="line">    <span class="type">bool</span> k;<span class="comment">//结果单元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nonRecKnap</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将第一个数据成员（递归起点）压入栈</span></span><br><span class="line">Stack&lt;knapNode&gt;stack;</span><br><span class="line">knapNode tmp;</span><br><span class="line">tmp.s=s;tmp.n=n;tmp.rd=<span class="number">0</span>;</span><br><span class="line">stack.<span class="built_in">push_back</span>(tmp)</span><br><span class="line">label <span class="number">0</span>:</span><br><span class="line">	stack.<span class="built_in">pop</span>(&amp;tmp);</span><br><span class="line">	<span class="keyword">if</span>(tmp.s==<span class="number">0</span>)&#123;</span><br><span class="line">	tmp.k=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">goto</span> label3;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((tmp.s&lt;<span class="number">0</span>)||(tmp.s&gt;<span class="number">0</span>&amp;&amp;tmp.n&lt;<span class="number">1</span>))&#123;</span><br><span class="line">        tmp.k=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">goto</span> label3;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="built_in">push</span>(tmp);<span class="comment">//没有满足出口条件</span></span><br><span class="line">    x.s=tmp.s-w[tmp.n<span class="number">-1</span>];</span><br><span class="line">    x.n=tmp.n<span class="number">-1</span>;</span><br><span class="line">    x.rd=<span class="number">1</span>;</span><br><span class="line">    stack.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">goto</span> label0;</span><br><span class="line">    label1:</span><br><span class="line">    stack.<span class="built_in">pop</span>(&amp;x);<span class="comment">//查看栈顶并分情况处理</span></span><br><span class="line">    <span class="keyword">if</span>(tmp.k==<span class="literal">true</span>)&#123;</span><br><span class="line">        x.k=<span class="literal">true</span>;</span><br><span class="line">        stack.<span class="built_in">push</span>(x);</span><br><span class="line">        cout&lt;&lt;w[x.n<span class="number">-1</span>]&lt;&lt;endl;<span class="comment">//输出物品</span></span><br><span class="line">        <span class="keyword">goto</span> label3;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="built_in">push</span>(x);<span class="comment">//某层结果单元为false</span></span><br><span class="line">    tmp.s=x.s;tmp.n=x.n<span class="number">-1</span>;tmp.rd=<span class="number">2</span>;</span><br><span class="line">    stack.<span class="built_in">push</span>(tmp);<span class="comment">//回溯</span></span><br><span class="line">    <span class="keyword">goto</span> label0;</span><br><span class="line">    label2:</span><br><span class="line">    stack.<span class="built_in">pop</span>(&amp;x);</span><br><span class="line">    x.k=tmp.k;<span class="comment">//结果单元上传给调用层</span></span><br><span class="line">    stack.<span class="built_in">push</span>(x);</span><br><span class="line">    label3:</span><br><span class="line">    stack.<span class="built_in">pop</span>(&amp;tmp);</span><br><span class="line">    <span class="keyword">switch</span>(tmp.rd)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> tmp.k;<span class="comment">//算法结束</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">goto</span> label1;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="keyword">goto</span> label2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合法出栈序列"><a href="#合法出栈序列" class="headerlink" title="&#x3D;&#x3D;合法出栈序列&#x3D;&#x3D;"></a>&#x3D;&#x3D;合法出栈序列&#x3D;&#x3D;</h2><ul>
<li>给定一个入栈序列s(string 类型)，要求输出一个result(vector<string>类型),result中存储着s的所有合法出栈序列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generatePopSequences</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="built_in">backtrack</span>(s, <span class="number">0</span>, stk, current, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> index, stack&lt;<span class="type">char</span>&gt;&amp; stk, string&amp; current, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果所有元素都已处理且栈为空，则当前序列是一个合法的出栈序列</span></span><br><span class="line">        <span class="keyword">if</span> (index == s.<span class="built_in">size</span>() &amp;&amp; stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还有元素未入栈，可以选择入栈</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="comment">// 选择入栈</span></span><br><span class="line">            stk.<span class="built_in">push</span>(s[index]);</span><br><span class="line">            <span class="built_in">backtrack</span>(s, index + <span class="number">1</span>, stk, current, result);</span><br><span class="line">            stk.<span class="built_in">pop</span>(); <span class="comment">// 回溯，撤销入栈操作</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果栈不为空，可以选择出栈</span></span><br><span class="line">        <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> top = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            current += top;</span><br><span class="line">            <span class="built_in">backtrack</span>(s, index, stk, current, result);</span><br><span class="line">            current.<span class="built_in">pop</span>(); <span class="comment">// 回溯，撤销出栈操作</span></span><br><span class="line">            stk.<span class="built_in">push</span>(top); <span class="comment">// 恢复栈状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Solution solution;</span><br><span class="line">    string s = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; sequences = solution.<span class="built_in">generatePopSequences</span>(s);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;所有合法的出栈序列为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; seq : sequences) &#123;</span><br><span class="line">        cout &lt;&lt; seq &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li><p>给定一个入栈序列，一个出栈序列，写一个程序，判断出栈序列是否合法（chatgpt o1生成）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidPopSequence</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pushSeq, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; popSeq)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入序列的长度 n: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pushSeq</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">popSeq</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入入栈序列（用空格分隔）: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; pushSeq[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入出栈序列（用空格分隔）: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; popSeq[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入序列是否包含相同的元素</span></span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">pushSet</span><span class="params">(pushSeq.begin(), pushSeq.end())</span></span>;</span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">popSet</span><span class="params">(popSeq.begin(), popSeq.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pushSet != popSet)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;入栈序列和出栈序列的元素不一致，无法比较。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isValidPopSequence</span>(pushSeq, popSeq))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出栈序列是合法的。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;出栈序列是不合法的。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidPopSequence</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pushSeq, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; popSeq)</span></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="type">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = pushSeq.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">// 将当前入栈元素压入栈中</span></span><br><span class="line">        s.<span class="built_in">push</span>(pushSeq[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查栈顶元素是否与当前出栈元素匹配</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() == popSeq[popIndex])&#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有出栈元素都匹配完，且栈为空，则合法</span></span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>给定一个入栈序列，序列长度为N，请计算由多少种出栈序列</p>
</li>
</ul>
<p>卡特兰数:$$\frac{1}{n+1} \binom{2n}{n} $$</p>
<p>其表示从(0,0)到(n,n)不穿过对角线的路径数</p>
<p>那么我们可以将栈的出栈序列这样抽象化，我们知道，在栈未完全弹出前，出栈的次数一定小于等于入栈的次数，我们将入栈看做(x,y)到(x+1,y)，出栈看做(x,y)到(x,y+1)，每一个路径都对应于一个出栈序列，那么我们可以知道，该路径肯定不会穿过对角线，因为栈的次数一定小于等于入栈的次数。则出栈序列个数就是卡特兰数</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023091129145.png" class="" title="image-20241023091129145">



<h3 id="队列的ADT"><a href="#队列的ADT" class="headerlink" title="队列的ADT"></a>队列的ADT</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023091432034.png" class="" title="image-20241023091432034">



<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="&#x3D;&#x3D;循环队列&#x3D;&#x3D;"></a>&#x3D;&#x3D;循环队列&#x3D;&#x3D;</h3><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>入队：</p>
<p>arr[rear]&#x3D;item;</p>
<p>rear&#x3D;(rear+1)%mSize;</p>
<p>出队：</p>
<p>item&#x3D;arr[front];</p>
<p>front&#x3D;(front+1)%mSize;</p>
<p>判断队满:</p>
<p>(rear+1)%mSize&#x3D;&#x3D;front;</p>
<p>判断队空</p>
<p>front&#x3D;&#x3D;rear</p>
<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023092340566.png" class="" title="image-20241023092340566">

<h2 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023111238323.png" class="" title="image-20241023111238323">



<p><strong>证明：</strong></p>
<p><strong>必要性（若输出序列可由栈操作得到，则不存在 (i &lt; j &lt; k)，使得 (p_i &gt; p_k &gt; p_j)：</strong></p>
<p>假设输出序列 (p_1, p_2, \dots, p_n) 可以通过栈操作得到。我们要证明在该序列中不存在下标 (i &lt; j &lt; k)，使得 (p_i &gt; p_k &gt; p_j)。</p>
<p>假设反设，存在 (i &lt; j &lt; k)，使得 (p_i &gt; p_k &gt; p_j)。考虑栈操作过程中的这三个元素：</p>
<ol>
<li><p><strong>元素 (p_i) 的出栈：</strong> 在位置 (i)，元素 (p_i) 被弹出栈。这意味着在此之前，元素 (1) 到 (p_i) 已经被压入栈或弹出。</p>
</li>
<li><p><strong>元素 (p_j) 的出栈：</strong> 在位置 (j)，元素 (p_j) 被弹出栈。由于 (p_j) 在 (p_i) 之后被弹出，且 (i &lt; j)，因此 (p_j) 必须在 (p_i) 被弹出后仍留在栈中。这意味着 (p_j) 在 (p_i) 之前被压入栈，但在 (p_i) 被弹出后才被弹出。</p>
</li>
<li><p><strong>元素 (p_k) 的出栈：</strong> 在位置 (k)，元素 (p_k) 被弹出栈。由于 (p_k) 介于 (p_i) 和 (p_j) 之间，且 (p_i &gt; p_k &gt; p_j)，这意味着在 (p_i) 被弹出后，(p_k) 被压入栈，并在 (p_j) 被弹出前被弹出。</p>
</li>
</ol>
<p>然而，这与栈的后进先出性质矛盾。因为 (p_j) 在 (p_i) 之前被压入栈，但在 (p_k) 之后被弹出，这不符合栈的操作规则。因此，假设不成立，输出序列中不存在这样的 (i, j, k)。</p>
<p><strong>充分性（若输出序列中不存在 (i &lt; j &lt; k)，使得 (p_i &gt; p_k &gt; p_j)，则可以通过栈操作得到该序列）：</strong></p>
<p>我们将构造一个栈操作序列，使得输入序列 (1, 2, \dots, n) 可以通过栈操作得到输出序列 (p_1, p_2, \dots, p_n)。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li><p><strong>初始化：</strong> 设栈为空，输入指针指向 (1)，输出指针指向 (p_1)。</p>
</li>
<li><p><strong>循环操作：</strong></p>
<ul>
<li><strong>步骤 A：</strong> 若栈顶元素等于当前输出指针指向的元素 (p_j)，则弹出栈顶元素，并将输出指针移动到下一个元素。</li>
<li><strong>步骤 B：</strong> 否则，若输入指针未超过 (n)，则将输入指针指向的元素压入栈，并将输入指针移动到下一个元素。</li>
<li><strong>步骤 C：</strong> 若输入指针已超过 (n)，但栈顶元素不等于 (p_j)，则算法失败，无法生成输出序列。</li>
</ul>
</li>
<li><p><strong>结束条件：</strong> 当输出指针超过 (n) 时，算法成功。</p>
</li>
</ol>
<p><strong>证明算法的正确性：</strong></p>
<ul>
<li><p><strong>栈的单调性：</strong> 在任何时刻，栈中的元素都是严格递减的。这是因为只有当栈顶元素等于当前需要输出的元素时才会弹出，否则只会压入更大的元素。</p>
</li>
<li><p><strong>避免 (p_i &gt; p_k &gt; p_j) 的情况：</strong> 由于序列中不存在 (p_i &gt; p_k &gt; p_j) 且 (i &lt; j &lt; k)，所以在上述算法中，不会遇到无法弹出栈顶元素且无法继续压栈的矛盾情况。</p>
</li>
</ul>
<p>因此，该算法能够成功地将输入序列通过栈操作得到输出序列 (p_1, p_2, \dots, p_n)。</p>
<p><strong>结论：</strong> 从初始输入序列 (1, 2, \dots, n)，可以利用一个栈得到输出序列 (p_1, p_2, \dots, p_n) 的充分必要条件是：输出序列中不存在下标 (i &lt; j &lt; k)，使得 (p_i &gt; p_k &gt; p_j)。</p>
<h1 id="第4章-字符串"><a href="#第4章-字符串" class="headerlink" title="第4章 字符串"></a>第4章 字符串</h1><p>一. 概念</p>
<ol>
<li>串 2. 模式匹配</li>
</ol>
<p>二. 方法</p>
<ol>
<li>串的基本操作</li>
<li>串的存储及运算</li>
</ol>
<p> ★ 3. <strong>串的KMP快速模式匹配算法，求特征向量数组（N数组）和利用N向量完成匹配的方法（注意变种KMP算法的特征定义、特征向量和KMP算法在字符串相关问题中的灵活应用）</strong></p>
<h2 id="串的KMP快速模式匹配算法"><a href="#串的KMP快速模式匹配算法" class="headerlink" title="串的KMP快速模式匹配算法"></a>串的KMP快速模式匹配算法</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023152459116.png" class="" title="image-20241023152459116">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023154634711.png" class="" title="image-20241023154634711">

<p>非优化的算法:（就是简单的最大的公共前后缀的长度）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">findNext</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,k;</span><br><span class="line">    <span class="type">int</span> m=P.<span class="built_in">length</span>();	<span class="comment">//m为模板P的长度</span></span><br><span class="line">    <span class="type">int</span>* next=<span class="keyword">new</span> <span class="type">int</span>[m];<span class="comment">//动态存储区开辟整数数组</span></span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;k=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果P[i]!=P[k],那么我们把k=next[k]，前面已经分析过，一直循环直到条件不满足</span></span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span>&amp;&amp;P[k]!=P[i])&#123;</span><br><span class="line">            k=next[k];<span class="comment">//k递归地向前找</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++;k++;<span class="comment">//找到相等的了，即P[i]==P[k]了，那么next[i+1]=k+1了</span></span><br><span class="line">        next[i]=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023155618729.png" class="" title="image-20241023155618729">

<ul>
<li>当P[i]&#x3D;&#x3D;P[k]时，考虑我们在比较P和T时，既然P[i]已经和T[j]不匹配了，我们回溯到P[k]，还是不匹配地，不如直接回溯到next[k]</li>
</ul>
<p>因此，回溯算法是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">findNext</span><span class="params">(string P)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,k;</span><br><span class="line">    <span class="type">int</span> m=P.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> *next=<span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    i=<span class="number">0</span>;k=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">0</span>&amp;&amp;P[k]!=P[i])&#123;</span><br><span class="line">            k=next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;k++;</span><br><span class="line">        <span class="keyword">if</span>(P[k]==P[i])&#123;</span><br><span class="line">            next[i]=next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            next[i]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;KMP模式匹配算法的&#x3D;&#x3D;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMPStrMatching</span><span class="params">(string T,string P,<span class="type">int</span> *N,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">    N=<span class="built_in">findNext</span>(P);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;	<span class="comment">//模式的下标变量</span></span><br><span class="line">    <span class="type">int</span> j=start;   <span class="comment">//目标的下标变量</span></span><br><span class="line">    <span class="type">int</span> pLen=P.<span class="built_in">length</span>(); <span class="comment">//模式的长度</span></span><br><span class="line">    <span class="type">int</span> tLen=T.<span class="built_in">length</span>(); <span class="comment">//目标的长度</span></span><br><span class="line">    <span class="keyword">if</span>(tLen-start&lt;pLen)&#123;<span class="comment">//若目标比模式段，匹配无法成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;pLen&amp;&amp;j&lt;tLen)&#123;<span class="comment">//反复比较对应字符来开始匹配</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">-1</span>||T[j]==P[i])&#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=N[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=pLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> (j-pLen<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>先看求next的数组的复杂度</p>
<p>我们注意到在while循环中i只增不减，因此时间复杂度为O(m)</p>
<p>对于KMP匹配，我们又注意到在while循环中j只增不减</p>
<p>因此KMP算法的时间复杂度是O(n+m)</p>
<h1 id="第5章-二叉树"><a href="#第5章-二叉树" class="headerlink" title="第5章 二叉树"></a>第5章 二叉树</h1><p>一. 概念</p>
<ol>
<li>二叉树 2.二叉树的深度优先遍历 3. 二叉搜索树BST 4. 堆 5. Huffman树、Huffman编码</li>
</ol>
<p>二. 方法</p>
<p>1．二叉树的链式存储（1）二叉链表（2）带父指针的三重链表</p>
<ol start="2">
<li>二叉树的顺序存储、完全二叉树的顺序存储</li>
</ol>
<p> ★ 3. 二叉树的深度优先遍历。要求自己能用<strong>递归解决二叉树应用问题</strong>；看得懂非递归二叉树遍历框架、<strong>可以完成采用非递归算法设计的算法填空</strong></p>
<ol start="4">
<li><strong>二叉树的广度优先遍历及其应用</strong></li>
</ol>
<p> ★ 5. <strong>二叉搜索树</strong>的插入与删除<br> ★ 6. 构造<strong>Huffman树</strong>，利用Huffman树进行编码、解码<br> ★ 7. <strong>堆</strong>的建立与维护过程</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>&#x3D;&#x3D;部分题在手写笔记上&#x3D;&#x3D;</p>
<ul>
<li>N个节点的二叉树有多少种不同的形态？</li>
<li>是一个Catalan数，即，$$\frac{1}{n+1}\binom{2n}{n}$$</li>
</ul>
<p>考虑其递归即可</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果一棵二叉树的结点，或为树叶（0度节点），或为两颗非空子树（2度节点），则称作满二叉树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023165316817.png" class="" title="image-20241023165316817">



<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241023165420441.png" class="" title="image-20241023165420441">

<p>&#x3D;&#x3D;完全二叉树的特点&#x3D;&#x3D;</p>
<ul>
<li>叶节点只可能在最下面两层出现</li>
<li>路径长度和最短（满二叉树不具有此性质）</li>
</ul>
<h2 id="扩充二叉树"><a href="#扩充二叉树" class="headerlink" title="扩充二叉树"></a>扩充二叉树</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241024085208408.png" class="" title="image-20241024085208408">

<h3 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241024085506125.png" class="" title="image-20241024085506125">

<h2 id="二叉树的周游"><a href="#二叉树的周游" class="headerlink" title="&#x3D;&#x3D;二叉树的周游&#x3D;&#x3D;"></a>&#x3D;&#x3D;二叉树的周游&#x3D;&#x3D;</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241024091722956.png" class="" title="image-20241024091722956">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinaryTree&lt;T&gt;::<span class="built_in">DepthOrder</span>(BinaryTreeNode&lt;T&gt;* root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">Visit</span>(root);	<span class="comment">//放这的时候是前序</span></span><br><span class="line">        <span class="built_in">DepthOrder</span>(root-&gt;<span class="built_in">leftchild</span>()); <span class="comment">//递归访问左子树</span></span><br><span class="line">        <span class="built_in">Visit</span>(root);	<span class="comment">//放这的时候是中序</span></span><br><span class="line">        <span class="built_in">DepthOrder</span>(root-&gt;<span class="built_in">rightchild</span>()); <span class="comment">//递归访问右子树</span></span><br><span class="line">        <span class="built_in">Visit</span>(root); <span class="comment">//后序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241024092203761.png" class="" title="image-20241024092203761">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">// 引入输入输出流库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span> <span class="comment">// 引入向量库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 声明一个全局向量，用于存储结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索函数，接受中序遍历和后序遍历的向量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;middle,vector&lt;<span class="type">int</span>&gt;post)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果中序数组的大小为0，说明没有节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(middle.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果中序数组的大小为1，说明只有一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(middle.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(middle[<span class="number">0</span>]); <span class="comment">// 将该节点添加到结果中</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将后序数组的最后一个元素作为根节点添加到结果中</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(post[post.<span class="built_in">size</span>() - <span class="number">1</span>]); <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>; <span class="comment">// 用于存储根节点在中序数组中的位置</span></span><br><span class="line">    <span class="comment">// 遍历中序数组，找到根节点的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; middle.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(middle[i]==post[post.<span class="built_in">size</span>() - <span class="number">1</span>])&#123;</span><br><span class="line">            pos = i; <span class="comment">// 找到位置，记录下来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 切分中序数组为左子树和右子树</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">middle_pre</span><span class="params">(middle.begin(), middle.begin() + pos)</span></span>; <span class="comment">// 左子树</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">middle_next</span><span class="params">(middle.begin() + pos + <span class="number">1</span>, middle.end())</span></span>; <span class="comment">// 右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切分后序数组为左子树和右子树</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">post_pre</span>(post.<span class="built_in">begin</span>(), post.<span class="built_in">begin</span>() + pos); <span class="comment">// 左子树</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">post_next</span>(post.<span class="built_in">begin</span>() + pos, post.<span class="built_in">end</span>() - <span class="number">1</span>); <span class="comment">// 右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归处理左子树</span></span><br><span class="line">    <span class="built_in">dfs</span>(middle_pre, post_pre);</span><br><span class="line">    <span class="comment">// 递归处理右子树</span></span><br><span class="line">    <span class="built_in">dfs</span>(middle_next, post_next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num; <span class="comment">// 声明一个向量用于存储输入的数字</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// 定义一个整型变量用于接收输入</span></span><br><span class="line">    <span class="comment">// 从标准输入中读取数字，直到输入结束</span></span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;i)&#123;</span><br><span class="line">        num.<span class="built_in">push_back</span>(i); <span class="comment">// 将输入的数字添加到向量num中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; middle; <span class="comment">// 声明一个向量用于存储中序数组</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; post; <span class="comment">// 声明一个向量用于存储后序数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将num数组的前一半添加到middle数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.<span class="built_in">size</span>()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        middle.<span class="built_in">push_back</span>(num[i]); <span class="comment">// 将前一半的元素添加到middle中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将num数组的后一半添加到post数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=num.<span class="built_in">size</span>()/<span class="number">2</span>;i&lt;num.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        post.<span class="built_in">push_back</span>(num[i]); <span class="comment">// 将后一半的元素添加到post中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用深度优先搜索函数</span></span><br><span class="line">    <span class="built_in">dfs</span>(middle, post);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出result中的数，每两个之间有空格分隔</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;result[i]&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">// 输出result数组的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递归深度优先遍历"><a href="#非递归深度优先遍历" class="headerlink" title="&#x3D;&#x3D;非递归深度优先遍历&#x3D;&#x3D;"></a>&#x3D;&#x3D;非递归深度优先遍历&#x3D;&#x3D;</h3><p>前序遍历非递归算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义树节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> t, TreeNode *leftt = <span class="literal">nullptr</span>, TreeNode *rightt = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data</span>(t), <span class="built_in">left</span>(leftt), <span class="built_in">right</span>(rightt) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序DFS遍历函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfs_pre</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result; <span class="comment">// 用于存储遍历结果</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 如果树为空，返回空向量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode *&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *current = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(current-&gt;data); <span class="comment">// 访问当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先压入右子节点，后压入左子节点，确保左子节点先被处理</span></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(current-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(current-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回遍历结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：创建示例树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">createSampleTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          2   3</span></span><br><span class="line"><span class="comment">         / \</span></span><br><span class="line"><span class="comment">        4   5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>));</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：释放树的内存，防止内存泄漏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">deleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">deleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建示例树</span></span><br><span class="line">    TreeNode *root = <span class="built_in">createSampleTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行前序DFS遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; traversal = <span class="built_in">dfs_pre</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印遍历结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前序DFS遍历结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : traversal)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">deleteTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非递归中序遍历二叉树算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义树节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> t, TreeNode *leftt = <span class="literal">nullptr</span>, TreeNode *rightt = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data</span>(t), <span class="built_in">left</span>(leftt), <span class="built_in">right</span>(rightt) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序DFS遍历函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfs_inorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;       <span class="comment">// 用于存储遍历结果</span></span><br><span class="line">    stack&lt;TreeNode *&gt; st;     <span class="comment">// 辅助栈</span></span><br><span class="line">    TreeNode *current = root; <span class="comment">// 当前节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一直向左子树遍历，并将沿途节点压入栈中</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当没有左子节点时，弹出栈顶节点，访问该节点</span></span><br><span class="line">        current = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(current-&gt;data); <span class="comment">// 访问当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转向右子节点，继续遍历</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回遍历结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：创建示例树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">createSampleTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          2   3</span></span><br><span class="line"><span class="comment">         / \</span></span><br><span class="line"><span class="comment">        4   5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>));</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：释放树的内存，防止内存泄漏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">deleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">deleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建示例树</span></span><br><span class="line">    TreeNode *root = <span class="built_in">createSampleTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行中序DFS遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; traversal = <span class="built_in">dfs_inorder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印遍历结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序DFS遍历结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : traversal)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">deleteTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>非递归后序遍历二叉树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义树节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> t, TreeNode *leftt = <span class="literal">nullptr</span>, TreeNode *rightt = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data</span>(t), <span class="built_in">left</span>(leftt), <span class="built_in">right</span>(rightt) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Tags</span></span><br><span class="line">&#123;</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StackElement</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pointer;</span><br><span class="line">    Tags tag;</span><br><span class="line">    <span class="built_in">StackElement</span>(TreeNode* cur,Tags tagg):<span class="built_in">pointer</span>(cur),<span class="built_in">tag</span>(tagg)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 后序DFS遍历函数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfs_inorder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;       <span class="comment">// 用于存储遍历结果</span></span><br><span class="line">    stack&lt;StackElement&gt; st;</span><br><span class="line">    TreeNode *current = root;</span><br><span class="line">    <span class="keyword">while</span>(current!=<span class="literal">NULL</span>||!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">StackElement</span>(current, Left));</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!current)&#123;</span><br><span class="line">            StackElement element = st.<span class="built_in">top</span>();</span><br><span class="line">            current = element.pointer;</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(element.tag==Left)&#123;</span><br><span class="line">                element.tag = Right;</span><br><span class="line">                st.<span class="built_in">push</span>(element);</span><br><span class="line">                current = current-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(current-&gt;data);</span><br><span class="line">                current = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回遍历结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：创建示例树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">createSampleTree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1</span></span><br><span class="line"><span class="comment">           / \</span></span><br><span class="line"><span class="comment">          2   3</span></span><br><span class="line"><span class="comment">         / \</span></span><br><span class="line"><span class="comment">        4   5</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>));</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：释放树的内存，防止内存泄漏</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">deleteTree</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">deleteTree</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建示例树</span></span><br><span class="line">    TreeNode *root = <span class="built_in">createSampleTree</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行后序DFS遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; traversal = <span class="built_in">dfs_inorder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印遍历结果</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;后序DFS遍历结果: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : traversal)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">deleteTree</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历二叉树"><a href="#广度优先遍历二叉树" class="headerlink" title="&#x3D;&#x3D;广度优先遍历二叉树&#x3D;&#x3D;"></a>&#x3D;&#x3D;广度优先遍历二叉树&#x3D;&#x3D;</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026094725644.png" class="" title="image-20241026094725644">

<h2 id="二叉搜索树的插入和删除"><a href="#二叉搜索树的插入和删除" class="headerlink" title="&#x3D;&#x3D;二叉搜索树的插入和删除&#x3D;&#x3D;"></a>&#x3D;&#x3D;二叉搜索树的插入和删除&#x3D;&#x3D;</h2><p>二叉搜索树(<code>BST</code>)，二叉排序树</p>
<ul>
<li>或者是一颗空树</li>
<li>或者是具有下列性质的二叉树<ul>
<li>对于任何一个节点，设其值为K，则该节点的左子树（若不空）的任意一个值都小于K</li>
<li>该节点的右子树（若不空）的任意一个节点的值都大于K</li>
<li>而且它的左右子树也分别为二叉搜索树</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026100613321.png" class="" title="image-20241026100613321">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026100636672.png" class="" title="image-20241026100636672">

<h3 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026100716484.png" class="" title="image-20241026100716484">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义树节点结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> t, TreeNode *leftt = <span class="literal">nullptr</span>, TreeNode *rightt = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">data</span>(t), <span class="built_in">left</span>(leftt), <span class="built_in">right</span>(rightt) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertNode</span><span class="params">(TreeNode* root,TreeNode* newpointer)</span></span>&#123;</span><br><span class="line">    TreeNode *pointer;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        root = newpointer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        pointer = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(newpointer-&gt;data==pointer-&gt;data)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(newpointer-&gt;data&lt;pointer-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pointer-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pointer-&gt;left = newpointer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pointer = pointer-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pointer-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pointer-&gt;right = newpointer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pointer = pointer-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="未优化"><a href="#未优化" class="headerlink" title="未优化"></a>未优化</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026101824840.png" class="" title="image-20241026101824840">

<h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026102108301.png" class="" title="image-20241026102108301">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinarySearchTree&lt;T&gt;::<span class="built_in">DeleteNodeEx</span>(BinaryTreeNode&lt;T&gt; *delpointer) &#123;</span><br><span class="line">    BinaryTreeNode&lt;T&gt; *replpointer;            <span class="comment">// 替换结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *replparent = <span class="literal">NULL</span>;      <span class="comment">// 替换结点的父结点</span></span><br><span class="line">    BinaryTreeNode&lt;T&gt; *delparent = <span class="built_in">Parent</span>(delpointer); <span class="comment">// 待删除结点父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若待删除结点的左子树为空，就将其右子树代替它</span></span><br><span class="line">    <span class="keyword">if</span> (delpointer-&gt;<span class="built_in">leftchild</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        replpointer = delpointer-&gt;<span class="built_in">rightchild</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待删除结点左子树不空，在左子树中寻找最大结点替换待删除结点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        replpointer = delpointer-&gt;<span class="built_in">leftchild</span>();</span><br><span class="line">        <span class="keyword">while</span> (replpointer-&gt;<span class="built_in">rightchild</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            replparent = replpointer;</span><br><span class="line">            replpointer = replpointer-&gt;<span class="built_in">rightchild</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 替换结点就是被删除结点的左子结点，左子树挂接为其父（被删）结点的左子树</span></span><br><span class="line">        <span class="keyword">if</span> (replparent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            delpointer-&gt;left = replpointer-&gt;<span class="built_in">leftchild</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换结点的左子树挂接为其父的右子树</span></span><br><span class="line">        <span class="keyword">else</span> replparent-&gt;right = replpointer-&gt;<span class="built_in">leftchild</span>();</span><br><span class="line">        </span><br><span class="line">        replpointer-&gt;left = delpointer-&gt;<span class="built_in">leftchild</span>();  <span class="comment">// 继承待删除结点左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    replpointer-&gt;right = delpointer-&gt;<span class="built_in">rightchild</span>();    <span class="comment">// 继承待删除结点右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用替换结点去替代真正的删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (delparent == <span class="literal">NULL</span>)</span><br><span class="line">        root = replpointer;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delparent-&gt;<span class="built_in">leftchild</span>() == delpointer)</span><br><span class="line">        delparent-&gt;left = replpointer;</span><br><span class="line">    <span class="keyword">else</span> delparent-&gt;right = replpointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> delpointer; <span class="comment">// 删除该结点</span></span><br><span class="line">    delpointer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="堆的建立和维护"><a href="#堆的建立和维护" class="headerlink" title="&#x3D;&#x3D;堆的建立和维护&#x3D;&#x3D;"></a>&#x3D;&#x3D;堆的建立和维护&#x3D;&#x3D;</h2><p>是完全二叉树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026103402231.png" class="" title="image-20241026103402231">



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 包含输入输出流库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">// 包含向量库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模板类 MinHeap，支持任意类型 T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinHeap</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *heapArray; <span class="comment">// 指向堆数组的指针</span></span><br><span class="line">    <span class="type">int</span> CurrentSize; <span class="comment">// 当前堆中元素的个数</span></span><br><span class="line">    <span class="type">int</span> MaxSize; <span class="comment">// 堆的最大容量</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuildHeap</span><span class="params">()</span></span>; <span class="comment">// 用于构建堆的私有方法</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="comment">// 私有交换函数，用于交换堆中的元素</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T temp = heapArray[i]; <span class="comment">// 用临时变量存储第 i 个元素</span></span><br><span class="line">        heapArray[i] = heapArray[j]; <span class="comment">// 将第 j 个元素赋值给第 i 个元素</span></span><br><span class="line">        heapArray[j] = temp; <span class="comment">// 将临时变量的值赋回到第 j 个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinHeap</span>(<span class="type">const</span> <span class="type">int</span> n, T heaparray[]) <span class="comment">// 构造函数，接受元素个数和数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="comment">// 如果元素个数小于等于 0，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        CurrentSize = n; <span class="comment">// 设置当前大小为 n</span></span><br><span class="line">        MaxSize = <span class="number">10000</span>; <span class="comment">// 设置堆的最大容量</span></span><br><span class="line">        heapArray = <span class="keyword">new</span> T[MaxSize]; <span class="comment">// 动态分配堆数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 将输入数组元素复制到堆数组中</span></span><br><span class="line">        &#123;</span><br><span class="line">            heapArray[i] = heaparray[i]; <span class="comment">// 赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BuildHeap</span>(); <span class="comment">// 构建堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MinHeap</span>() &#123; <span class="keyword">delete</span>[] heapArray; &#125; <span class="comment">// 析构函数，释放堆数组内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取左子节点的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leftchild</span><span class="params">(<span class="type">int</span> pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">1</span>; <span class="comment">// 左子节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取右子节点的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rightchild</span><span class="params">(<span class="type">int</span> pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * pos + <span class="number">2</span>; <span class="comment">// 右子节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父节点的索引</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> pos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pos - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 父节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下筛选函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftDown</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = pos; <span class="comment">// 当前节点的位置</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点的位置</span></span><br><span class="line">        T temp = heapArray[i]; <span class="comment">// 保存当前节点的值</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt; CurrentSize) <span class="comment">// 当左子节点在堆的有效范围内</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((j + <span class="number">1</span> &lt; CurrentSize) &amp;&amp; heapArray[j] &gt; heapArray[j + <span class="number">1</span>])</span><br><span class="line">            &#123; <span class="comment">// 如果右子节点存在且小于左子节点，更新 j 为右子节点</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; heapArray[j]) <span class="comment">// 如果当前节点值大于子节点值</span></span><br><span class="line">            &#123;</span><br><span class="line">                heapArray[i] = heapArray[j]; <span class="comment">// 将子节点值上移</span></span><br><span class="line">                i = j; <span class="comment">// 更新当前节点为子节点</span></span><br><span class="line">                j = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 更新 j 为新的左子节点位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果当前节点值不大于子节点值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        heapArray[i] = temp; <span class="comment">// 将保存的当前值放入正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上筛选函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SiftUp</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> temppos = pos; <span class="comment">// 当前节点位置</span></span><br><span class="line">        T temp = heapArray[temppos]; <span class="comment">// 保存当前节点的值</span></span><br><span class="line">        <span class="keyword">while</span> ((temppos &gt; <span class="number">0</span>) &amp;&amp; (heapArray[<span class="built_in">parent</span>(temppos)] &gt; temp))</span><br><span class="line">        &#123;</span><br><span class="line">            heapArray[temppos] = heapArray[<span class="built_in">parent</span>(temppos)]; <span class="comment">// 将父节点上移</span></span><br><span class="line">            temppos = <span class="built_in">parent</span>(temppos); <span class="comment">// 更新当前节点位置为父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        heapArray[temppos] = temp; <span class="comment">// 将保存的值放回到正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> T &amp;newNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSize == MaxSize) <span class="comment">// 如果当前大小等于最大容量，返回 false</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        heapArray[CurrentSize] = newNode; <span class="comment">// 将新节点添加到堆的末尾</span></span><br><span class="line">        <span class="built_in">SiftUp</span>(CurrentSize); <span class="comment">// 向上筛选以保持堆的性质</span></span><br><span class="line">        CurrentSize++; <span class="comment">// 更新当前堆大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除堆中最小值</span></span><br><span class="line">    <span class="function">T <span class="title">RemoveMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">// 从堆顶删除最小值</span></span><br><span class="line">        <span class="keyword">if</span> (CurrentSize == <span class="number">0</span>) <span class="comment">// 如果堆为空</span></span><br><span class="line">        &#123; </span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Can&#x27;t Delete&quot;</span>; <span class="comment">// 输出不能删除的提示</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>); <span class="comment">// 退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            T minValue = heapArray[<span class="number">0</span>]; <span class="comment">// 保存当前堆顶的最小值</span></span><br><span class="line">            heapArray[<span class="number">0</span>] = heapArray[--CurrentSize]; <span class="comment">// 将最后一个元素放到堆顶并减少当前大小</span></span><br><span class="line">            <span class="keyword">if</span> (CurrentSize &gt; <span class="number">1</span>) <span class="comment">// 如果堆中还有多个元素</span></span><br><span class="line">                <span class="built_in">SiftDown</span>(<span class="number">0</span>); <span class="comment">// 从堆顶开始向下筛选</span></span><br><span class="line">            <span class="keyword">return</span> minValue; <span class="comment">// 返回删除的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据位置删除指定节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Remove</span><span class="params">(<span class="type">int</span> pos, T &amp;node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((pos &lt; <span class="number">0</span>) || pos &gt;= CurrentSize) <span class="comment">// 如果位置无效</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = heapArray[pos]; <span class="comment">// 保存要删除的节点值</span></span><br><span class="line">        heapArray[pos] = heapArray[--CurrentSize]; <span class="comment">// 将最后一个元素放到删除的位置并减少当前大小</span></span><br><span class="line">        <span class="built_in">SiftUp</span>(pos); <span class="comment">// 向上筛选</span></span><br><span class="line">        <span class="built_in">SiftDown</span>(pos); <span class="comment">// 向下筛选</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 删除成功，返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于构建堆的私有方法的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> MinHeap&lt;T&gt;::<span class="built_in">BuildHeap</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，向前遍历所有节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">parent</span>(CurrentSize - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">SiftDown</span>(i); <span class="comment">// 对当前节点执行向下筛选操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026104941956.png" class="" title="image-20241026104941956">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026105055218.png" class="" title="image-20241026105055218">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026105210295.png" class="" title="image-20241026105210295">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026105349455.png" class="" title="image-20241026105349455">

<h3 id="构造Huffman树，利用Huffman树进行编码、解码"><a href="#构造Huffman树，利用Huffman树进行编码、解码" class="headerlink" title="&#x3D;&#x3D;构造Huffman树，利用Huffman树进行编码、解码&#x3D;&#x3D;"></a>&#x3D;&#x3D;构造<strong>Huffman树</strong>，利用Huffman树进行编码、解码&#x3D;&#x3D;</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026105735890.png" class="" title="image-20241026105735890">

<p>定义：具有最小带权路径长度的二叉树称作哈夫曼 （Huffman）树（或称最优二叉树）</p>
<h3 id="建立Huffman编码树的过程"><a href="#建立Huffman编码树的过程" class="headerlink" title="建立Huffman编码树的过程"></a>建立Huffman编码树的过程</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026105852161.png" class="" title="image-20241026105852161">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026110021665.png" class="" title="image-20241026110021665">

<h3 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026110058481.png" class="" title="image-20241026110058481">

<h3 id="译码"><a href="#译码" class="headerlink" title="译码"></a>译码</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026110417850.png" class="" title="image-20241026110417850">

<h1 id="第6章-树"><a href="#第6章-树" class="headerlink" title="第6章 树"></a>第6章 树</h1><p>一. 概念</p>
<ol>
<li>树、森林 2. 树的先根遍历、后根遍历、层次遍历 ★3. K叉树</li>
</ol>
<p>二. 方法</p>
<p>★ 1. 森林与二叉树相互转换<br> 2．森林的链式存储<br> ★ (1) 转换为相应的二叉树，用<strong>二叉链</strong>表示<br> (2) 父指针表示法<br> (3) 子结点表表示法<br> （4）等价类和<strong>并查算法</strong>的应用<br> ★ 3. 森林的<strong>深度优先遍历</strong>（递归），可能结合应用</p>
<ol start="4">
<li>森林的<strong>层次遍历</strong>(用队列)，可能结合应用</li>
</ol>
<p> ★ 5. 森林&#x2F;二叉树的<strong>顺序存储</strong>（不必死记各种顺序存储方法，要了解原理。其本质是按照遍历的性质，把内存中森林&#x2F;二叉树输出一个顺序存储的序列，反过来也可以根据相应的顺序存储的序列构造内存中的森林&#x2F;二叉树）</p>
<h2 id="森林和二叉树的相互转换"><a href="#森林和二叉树的相互转换" class="headerlink" title="&#x3D;&#x3D;森林和二叉树的相互转换&#x3D;&#x3D;"></a>&#x3D;&#x3D;森林和二叉树的相互转换&#x3D;&#x3D;</h2><h3 id="森林转换成二叉树"><a href="#森林转换成二叉树" class="headerlink" title="森林转换成二叉树"></a>森林转换成二叉树</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026185547793.png" class="" title="image-20241026185547793">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode *<span class="title">forestToBinaryTree</span><span class="params">(<span class="type">const</span> Forest &amp;forest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (forest.<span class="built_in">empty</span>()) <span class="comment">// 检查森林是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果为空，返回空指针</span></span><br><span class="line"></span><br><span class="line">    BinaryTreeNode *root = <span class="literal">nullptr</span>; <span class="comment">// 二叉树根节点初始化为空</span></span><br><span class="line">    BinaryTreeNode *current = <span class="literal">nullptr</span>; <span class="comment">// 当前节点初始化为空</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TreeNode *tree : forest) <span class="comment">// 遍历森林中的每棵树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="comment">// 如果二叉树根节点为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="built_in">treeToBinaryTree</span>(tree); <span class="comment">// 将当前树转换为二叉树根节点</span></span><br><span class="line">            current = root; <span class="comment">// 当前节点设为二叉树根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果二叉树根节点不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            current-&gt;right = <span class="built_in">treeToBinaryTree</span>(tree); <span class="comment">// 将当前树转换为右节点</span></span><br><span class="line">            current = current-&gt;right; <span class="comment">// 移动到下一个右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">// 返回生成的二叉树根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="树换成二叉树"><a href="#树换成二叉树" class="headerlink" title="树换成二叉树"></a>树换成二叉树</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026111659338.png" class="" title="image-20241026111659338">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树转换为二叉树</span></span><br><span class="line"><span class="function">BinaryTreeNode *<span class="title">treeToBinaryTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="comment">// 检查树根节点是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果为空，返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个二叉树根节点，值与树根节点相同</span></span><br><span class="line">    BinaryTreeNode *binarytreeroot = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>(root-&gt;value);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;children.<span class="built_in">size</span>()) <span class="comment">// 如果有子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        binarytreeroot-&gt;left = <span class="built_in">treeToBinaryTree</span>(root-&gt;children[<span class="number">0</span>]); <span class="comment">// 将第一个子节点转换为二叉树左子树</span></span><br><span class="line">        BinaryTreeNode *current = binarytreeroot-&gt;left; <span class="comment">// 当前节点设为左子节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; root-&gt;children.<span class="built_in">size</span>(); i++) <span class="comment">// 遍历剩下的子节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            current-&gt;right = <span class="built_in">treeToBinaryTree</span>(root-&gt;children[i]); <span class="comment">// 将子节点转换为右子树</span></span><br><span class="line">            current = current-&gt;right; <span class="comment">// 移动到下一个右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarytreeroot; <span class="comment">// 返回生成的二叉树根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二叉树转换成森林"><a href="#二叉树转换成森林" class="headerlink" title="二叉树转换成森林"></a>二叉树转换成森林</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026185738318.png" class="" title="image-20241026185738318">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树转换为森林</span></span><br><span class="line"><span class="function">Forest <span class="title">binaryTreeToForest</span><span class="params">(BinaryTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Forest forest; <span class="comment">// 创建一个森林（树的集合）</span></span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="comment">// 检查根节点是否为空</span></span><br><span class="line">        <span class="keyword">return</span> forest; <span class="comment">// 如果为空，返回空森林</span></span><br><span class="line">    BinaryTreeNode *current = root; <span class="comment">// 当前节点设为根节点</span></span><br><span class="line">    <span class="keyword">while</span>(current-&gt;right) <span class="comment">// 遍历右兄弟节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        forest.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(current-&gt;right)); <span class="comment">// 将右兄弟节点转换为树并添加到森林</span></span><br><span class="line">        current = current-&gt;right; <span class="comment">// 移动到下一个右节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    forest.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(root)); <span class="comment">// 将根节点转换为树并添加到森林</span></span><br><span class="line">    <span class="keyword">return</span> forest; <span class="comment">// 返回生成的森林</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="二叉树为树"><a href="#二叉树为树" class="headerlink" title="二叉树为树"></a>二叉树为树</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026185905969.png" class="" title="image-20241026185905969">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二叉树转换为树</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">binaryTreeToTree</span><span class="params">(BinaryTreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="comment">// 检查根节点是否为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 如果为空，返回空指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个树的根节点，值与二叉树根节点相同</span></span><br><span class="line">    TreeNode *treeRoot = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理左子树，转换为孩子</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) <span class="comment">// 如果左子节点存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        treeRoot-&gt;children.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(root-&gt;left)); <span class="comment">// 将左子树转换为树节点并添加为孩子</span></span><br><span class="line">        BinaryTreeNode *current = root-&gt;left; <span class="comment">// 当前节点设为左子节点</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;right) <span class="comment">// 遍历右兄弟节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            treeRoot-&gt;children.<span class="built_in">push_back</span>(<span class="built_in">binaryTreeToTree</span>(current-&gt;right)); <span class="comment">// 将右兄弟节点转换为树节点并添加为孩子</span></span><br><span class="line">            current = current-&gt;right; <span class="comment">// 移动到下一个右节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeRoot; <span class="comment">// 返回生成的树节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的周游"><a href="#树的周游" class="headerlink" title="树的周游"></a>树的周游</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026190203194.png" class="" title="image-20241026190203194">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026192543715.png" class="" title="image-20241026192543715">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026192553601.png" class="" title="image-20241026192553601">











<h3 id="树的链式存储"><a href="#树的链式存储" class="headerlink" title="&#x3D;&#x3D;树的链式存储&#x3D;&#x3D;"></a>&#x3D;&#x3D;树的链式存储&#x3D;&#x3D;</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026190903311.png" class="" title="image-20241026190903311">

<p>&#x3D;&#x3D;这种方法本质是将树转化成二叉树，再存储该二叉树的二叉链的表示&#x3D;&#x3D;</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026190951189.png" class="" title="image-20241026190951189">

<p>树的抽象数据类型的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">// 引入输入输出流库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>   <span class="comment">// 引入向量库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span>    <span class="comment">// 引入队列库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类 TreeNode</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value; <span class="comment">// 节点的值</span></span><br><span class="line">        TreeNode&lt;T&gt; *pChild;    <span class="comment">// 左孩子指针</span></span><br><span class="line">        TreeNode&lt;T&gt; *pSibling;  <span class="comment">// 右兄弟指针</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数，用于初始化节点值，并将孩子和兄弟指针设置为空</span></span><br><span class="line">        <span class="built_in">TreeNode</span>(T a):<span class="keyword">this</span>-&gt;<span class="built_in">value</span>(a)&#123;</span><br><span class="line">            pChild = <span class="literal">NULL</span>; <span class="comment">// 初始化左孩子为NULL</span></span><br><span class="line">            pSibling = <span class="literal">NULL</span>; <span class="comment">// 初始化右兄弟为NULL</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断当前节点是否是叶子节点（没有孩子）</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> TreeNode&lt;T&gt; <span class="title">isLeaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pChild == <span class="literal">NULL</span>; <span class="comment">// 如果左孩子为NULL，返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在当前节点的孩子位置插入一个新的节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">InsertFirst</span><span class="params">(TreeNode&lt;T&gt;* node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(pChild)&#123; <span class="comment">// 如果当前节点有孩子</span></span><br><span class="line">                node-&gt;pSibling = pChild; <span class="comment">// 新节点的兄弟指向当前的第一个孩子</span></span><br><span class="line">                pChild = node; <span class="comment">// 将新节点插入为第一个孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 如果当前节点没有孩子</span></span><br><span class="line">                pChild = node; <span class="comment">// 直接将新节点作为孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个模板类 Tree</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    TreeNode&lt;T&gt; *root; <span class="comment">// 树的根节点</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 查找当前节点的父节点</span></span><br><span class="line">        <span class="function">TreeNode&lt;T&gt; *<span class="title">Parent</span><span class="params">(TreeNode&lt;T&gt; *current)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode&lt;T&gt; *&gt; que; <span class="comment">// 创建一个队列用于层次遍历</span></span><br><span class="line">            TreeNode&lt;T&gt; *pointer = root; <span class="comment">// 从根节点开始遍历</span></span><br><span class="line">            TreeNode&lt;T&gt; *last_pointer = <span class="literal">NULL</span>; <span class="comment">// 记录上一个节点</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!current || current == pointer)&#123; <span class="comment">// 如果当前节点为空或是根节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 返回NULL，表示没有父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 遍历整个树</span></span><br><span class="line">                <span class="keyword">while</span>(pointer)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(current == pointer)&#123; <span class="comment">// 如果当前节点是树的根节点</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 直接返回NULL</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(pointer); <span class="comment">// 将当前节点加入队列</span></span><br><span class="line">                    pointer = pointer-&gt;pSibling; <span class="comment">// 移动到下一个兄弟节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 队列不为空时，遍历队列找到当前节点的父节点</span></span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                last_pointer = que.<span class="built_in">front</span>(); <span class="comment">// 取队列头部元素</span></span><br><span class="line">                que.<span class="built_in">pop</span>(); <span class="comment">// 弹出队列头部元素</span></span><br><span class="line">                pointer = last_pointer-&gt;pChild; <span class="comment">// 移动到当前节点的孩子</span></span><br><span class="line">                <span class="keyword">while</span>(pointer)&#123; <span class="comment">// 对孩子进行遍历</span></span><br><span class="line">                    <span class="keyword">if</span>(pointer == current)&#123; <span class="comment">// 找到当前节点</span></span><br><span class="line">                        <span class="keyword">return</span> last_pointer; <span class="comment">// 返回当前节点的父节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(pointer); <span class="comment">// 将孩子节点加入队列</span></span><br><span class="line">                    pointer = pointer-&gt;pSibling; <span class="comment">// 移动到下一个兄弟节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找当前节点的前驱兄弟节点</span></span><br><span class="line">        <span class="function">TreeNode&lt;T&gt; *<span class="title">PrevSibling</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            TreeNode&lt;T&gt; *pointer = <span class="built_in">Parent</span>(node); <span class="comment">// 找到当前节点的父节点</span></span><br><span class="line">            TreeNode&lt;T&gt; *ppChild; <span class="comment">// 用于存储父节点的孩子</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果找到父节点</span></span><br><span class="line">            <span class="keyword">if</span> (pointer)</span><br><span class="line">            &#123;</span><br><span class="line">                ppChild = pointer-&gt;pChild; <span class="comment">// 获取父节点的第一个孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果没有父节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                ppChild = root; <span class="comment">// 将ppChild指向根节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前节点是第一个子节点，返回NULL</span></span><br><span class="line">            <span class="keyword">if</span> (ppChild == node)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 返回NULL，表明没有前驱兄弟</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历兄弟节点，寻找前驱兄弟</span></span><br><span class="line">            <span class="keyword">while</span> (ppChild)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ppChild-&gt;pSibling == node) <span class="comment">// 如果兄弟节点是当前节点的前驱</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> ppChild; <span class="comment">// 返回前驱兄弟节点</span></span><br><span class="line">                &#125;</span><br><span class="line">                ppChild = ppChild-&gt;pSibling; <span class="comment">// 移动至下一个兄弟节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有找到前驱兄弟节点，返回NULL</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DestoryNodes</span><span class="params">(TreeNode&lt;T&gt; *root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root)&#123; <span class="comment">// 如果节点为空</span></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">DestoryNodes</span>(root-&gt;pChild); <span class="comment">// 递归销毁孩子节点</span></span><br><span class="line">            <span class="built_in">DestoryNodes</span>(root-&gt;pSibling); <span class="comment">// 递归销毁兄弟节点</span></span><br><span class="line">            <span class="keyword">delete</span> root; <span class="comment">// 删除当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除一个子树</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">DeleteSubTree</span><span class="params">(TreeNode&lt;T&gt; *subroot)</span></span>&#123;</span><br><span class="line">            TreeNode&lt;T&gt; *pointer = <span class="built_in">PrevSibling</span>(subroot); <span class="comment">// 找到子树根节点的前驱兄弟</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!pointer)&#123; <span class="comment">// 如果没有前驱兄弟</span></span><br><span class="line">                pointer = <span class="built_in">Parent</span>(subroot); <span class="comment">// 找到父节点</span></span><br><span class="line">                <span class="keyword">if</span>(pointer)&#123; <span class="comment">// 如果找到父节点</span></span><br><span class="line">                    pointer-&gt;pChild = subroot-&gt;pSibling; <span class="comment">// 让父节点的孩子指向子树的下一个兄弟</span></span><br><span class="line">                    subroot-&gt;pSibling = <span class="literal">NULL</span>; <span class="comment">// 断开子树根与兄弟的连接</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123; <span class="comment">// 如果没有父节点，意味着要删除的是根的子树</span></span><br><span class="line">                    root = subroot-&gt;pSibling; <span class="comment">// 更新根节点为子树的下一个兄弟</span></span><br><span class="line">                    subroot-&gt;pSibling = <span class="literal">NULL</span>; <span class="comment">// 断开子树根与兄弟的连接</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 如果找到了前驱兄弟</span></span><br><span class="line">                pointer-&gt;pSibling = subroot-&gt;pSibling; <span class="comment">// 让前驱兄弟指向子树的下一个兄弟</span></span><br><span class="line">                subroot-&gt;pSibling = <span class="literal">NULL</span>; <span class="comment">// 断开子树根与兄弟的连接</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">DestoryNodes</span>(subroot); <span class="comment">// 销毁子树</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="父指针表示法及在并查集中的应用"><a href="#父指针表示法及在并查集中的应用" class="headerlink" title="&#x3D;&#x3D;父指针表示法及在并查集中的应用&#x3D;&#x3D;"></a>&#x3D;&#x3D;父指针表示法及在并查集中的应用&#x3D;&#x3D;</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026191406021.png" class="" title="image-20241026191406021">

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul>
<li>并查集是一种特殊集合，由不相交子集构成</li>
<li>基本操作<ul>
<li>Find：判断两个节点是否在同一个集合中</li>
<li>Union：归并两个集合</li>
</ul>
</li>
<li>并查集可用于求解等价类问题</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026191624348.png" class="" title="image-20241026191624348">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026191856606.png" class="" title="image-20241026191856606">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026192253357.png" class="" title="image-20241026192253357">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">// 引入输入输出流库，用于读取输入和输出结果</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>   <span class="comment">// 引入向量库，用于创建和管理动态数组</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 使用标准命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 partreenode 类，表示树的节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">partreenode</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> value; <span class="comment">// 节点的值</span></span><br><span class="line">        partreenode *parent=<span class="literal">NULL</span>; <span class="comment">// 指向父节点的指针，初始为空</span></span><br><span class="line">        <span class="type">int</span> nCount=<span class="number">0</span>; <span class="comment">// 子节点数量计数器，初始为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置父节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setParent</span><span class="params">(partreenode* p)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent = p; <span class="comment">// 将当前节点的父节点设置为 p</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置子节点数量</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setCount</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;nCount = n; <span class="comment">// 将子节点数量设置为 n</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 带参数的构造函数，用于初始化节点值</span></span><br><span class="line">        <span class="built_in">partreenode</span>(<span class="type">int</span> v):<span class="built_in">value</span>(v)&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">partreenode</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 partree 类，表示树数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">partree</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;partreenode *&gt; array; <span class="comment">// 存储树节点的动态数组</span></span><br><span class="line">        <span class="type">int</span> size; <span class="comment">// 树的大小</span></span><br><span class="line">        <span class="type">int</span> result; <span class="comment">// 用于保存结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 带参数的构造函数，初始化树的大小和结果</span></span><br><span class="line">        <span class="built_in">partree</span>(<span class="type">int</span> sizee,<span class="type">int</span> resultt) :<span class="built_in">size</span>(sizee),<span class="built_in">result</span>(resultt)&#123;</span><br><span class="line">            <span class="comment">// 初始化树节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size;i++)&#123;</span><br><span class="line">                array.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">partreenode</span>(i + <span class="number">1</span>)); <span class="comment">// 逐个创建节点，并存入数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查找节点的根节点，使用路径压缩</span></span><br><span class="line">        <span class="function">partreenode* <span class="title">find</span><span class="params">(partreenode* node)</span><span class="type">const</span></span>&#123;</span><br><span class="line">            <span class="comment">// 如果当前节点没有父节点，则返回该节点</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;parent==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 递归查找父节点，并进行路径压缩</span></span><br><span class="line">            node-&gt;<span class="built_in">setParent</span>(<span class="built_in">find</span>(node-&gt;parent)); </span><br><span class="line">            <span class="keyword">return</span> node-&gt;parent; <span class="comment">// 返回节点的父节点</span></span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并两个节点的集合</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            partreenode *pointeri = <span class="built_in">find</span>(array[i]); <span class="comment">// 查找第 i 个节点的根</span></span><br><span class="line">            partreenode *pointerj = <span class="built_in">find</span>(array[j]); <span class="comment">// 查找第 j 个节点的根</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果两个节点不在同一个集合中</span></span><br><span class="line">            <span class="keyword">if</span>(pointeri!=pointerj)&#123;</span><br><span class="line">                <span class="comment">// 合并操作，保持树的平衡</span></span><br><span class="line">                <span class="keyword">if</span>(pointeri-&gt;nCount&gt;=pointerj-&gt;nCount)&#123;</span><br><span class="line">                    pointerj-&gt;<span class="built_in">setParent</span>(pointeri); <span class="comment">// 将 j 的根设置为 i</span></span><br><span class="line">                    pointeri-&gt;<span class="built_in">setCount</span>(pointeri-&gt;nCount + pointerj-&gt;nCount); <span class="comment">// 更新 i 的子节点数量</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pointeri-&gt;<span class="built_in">setParent</span>(pointerj); <span class="comment">// 将 i 的根设置为 j</span></span><br><span class="line">                    pointerj-&gt;<span class="built_in">setCount</span>(pointeri-&gt;nCount + pointerj-&gt;nCount); <span class="comment">// 更新 j 的子节点数量</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>-&gt;result--; <span class="comment">// 合并后结果减少一个集合</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查两个节点是否在不同的集合中</span></span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">Different</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">            partreenode *pointeri = <span class="built_in">find</span>(array[i]); <span class="comment">// 查找第 i 个节点的根</span></span><br><span class="line">            partreenode *pointerj = <span class="built_in">find</span>(array[j]); <span class="comment">// 查找第 j 个节点的根</span></span><br><span class="line">            <span class="keyword">return</span> pointeri != pointerj; <span class="comment">// 返回是否在不同集合中</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n; <span class="comment">// 定义 m 和 n，分别表示节点数和边数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// 案例编号初始为1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环读取输入</span></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="comment">// 如果输入为 0 0，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个 partree 对象，初始化节点数和结果</span></span><br><span class="line">        partree *tree = <span class="keyword">new</span> <span class="built_in">partree</span>(n, n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环读取边的连接关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a, b; <span class="comment">// 定义两个节点</span></span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b; <span class="comment">// 读取节点 a 和 b</span></span><br><span class="line">            tree-&gt;<span class="built_in">Union</span>(a - <span class="number">1</span>, b - <span class="number">1</span>); <span class="comment">// 合并这两个节点的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出当前案例的结果</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span> &lt;&lt; tree-&gt;result &lt;&lt; endl; <span class="comment">// 打印连接组件的数量</span></span><br><span class="line">        i++; <span class="comment">// 案例编号自增</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的顺序存储方法"><a href="#树的顺序存储方法" class="headerlink" title="&#x3D;&#x3D;树的顺序存储方法&#x3D;&#x3D;"></a>&#x3D;&#x3D;树的顺序存储方法&#x3D;&#x3D;</h2><p>本质是按照树遍历的次序进行节点存储</p>
<h3 id="带右链的先根次序表示法"><a href="#带右链的先根次序表示法" class="headerlink" title="带右链的先根次序表示法"></a>带右链的先根次序表示法</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026193323505.png" class="" title="image-20241026193323505">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026193347761.png" class="" title="image-20241026193347761">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026193450202.png" class="" title="image-20241026193450202">

<p>先转换成二叉树，再搞</p>
<h3 id="带双标记位的先根次序表示法"><a href="#带双标记位的先根次序表示法" class="headerlink" title="带双标记位的先根次序表示法"></a>带双标记位的先根次序表示法</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026193544530.png" class="" title="image-20241026193544530">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026194044660.png" class="" title="image-20241026194044660">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026194111672.png" class="" title="image-20241026194111672">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026194906851.png" class="" title="image-20241026194906851">



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DualTagTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 双标记位先根次序树结点类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T info;   <span class="comment">// 树结点信息，存储节点的数据</span></span><br><span class="line">    <span class="type">int</span> ltag; <span class="comment">// 左标记，用于表示左子树的存在情况</span></span><br><span class="line">    <span class="type">int</span> rtag; <span class="comment">// 右标记，用于表示右兄弟的存在情况</span></span><br><span class="line">    <span class="built_in">DualTagTreeNode</span>(); <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DualTagTreeNode</span>(); <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DualTagTreeNode&lt;T&gt;::<span class="built_in">DualTagTreeNode</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ltag = <span class="number">1</span>; <span class="comment">// 初始化左标记为1，表示左子树存在</span></span><br><span class="line">    rtag = <span class="number">1</span>; <span class="comment">// 初始化右标记为1，表示右兄弟存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">DualTagTreeNode&lt;T&gt;::~<span class="built_in">DualTagTreeNode</span>() &#123;&#125; <span class="comment">// 析构函数定义，当前未进行任何操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是构造左子结点右兄弟树的算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Tree&lt;T&gt;::<span class="built_in">Tree</span>(DualTagTreeNode&lt;T&gt; *nodeArray, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> std::stack; <span class="comment">// 使用标准库中的栈</span></span><br><span class="line">    stack&lt;TreeNode&lt;T&gt; *&gt; aStack; <span class="comment">// 创建一个栈，用于存储树节点指针</span></span><br><span class="line">    TreeNode&lt;T&gt; *pointer = <span class="keyword">new</span> TreeNode&lt;T&gt;; <span class="comment">// 创建一个新的树结点指针</span></span><br><span class="line">    root = pointer; <span class="comment">// 将根节点指针指向新的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历节点数组，构建树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pointer-&gt;<span class="built_in">setValue</span>(nodeArray[i].info); <span class="comment">// 设置当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].rtag == <span class="number">0</span>) <span class="comment">// 如果有右兄弟</span></span><br><span class="line">            aStack.<span class="built_in">push</span>(pointer); <span class="comment">// 将当前指针压入栈中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 如果没有右兄弟</span></span><br><span class="line">            pointer-&gt;<span class="built_in">setSibling</span>(<span class="literal">NULL</span>); <span class="comment">// 设置当前指针的兄弟域为空</span></span><br><span class="line"></span><br><span class="line">        TreeNode&lt;T&gt; *tempPointer = <span class="keyword">new</span> TreeNode&lt;T&gt;; <span class="comment">// 创建一个临时指针，用于下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (nodeArray[i].ltag == <span class="number">0</span>) <span class="comment">// 如果有孩子</span></span><br><span class="line">            pointer-&gt;<span class="built_in">setChild</span>(tempPointer); <span class="comment">// 设置当前指针的孩子为临时指针</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 如果没有孩子</span></span><br><span class="line">            pointer-&gt;<span class="built_in">setChild</span>(<span class="literal">NULL</span>); <span class="comment">// 设置孩子域为空</span></span><br><span class="line">            pointer = aStack.<span class="built_in">pop</span>(); <span class="comment">// 从栈中弹出一个指针</span></span><br><span class="line">            pointer-&gt;<span class="built_in">setSibling</span>(tempPointer); <span class="comment">// 将弹出的指针的兄弟域设置为临时指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        pointer = tempPointer; <span class="comment">// 更新当前指针为临时指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理最后一个节点</span></span><br><span class="line">    pointer-&gt;<span class="built_in">setValue</span>(nodeArray[count - <span class="number">1</span>].info); <span class="comment">// 设置最后一个节点的值</span></span><br><span class="line">    pointer-&gt;<span class="built_in">setChild</span>(<span class="literal">NULL</span>); <span class="comment">// 设定最后一个节点的孩子为空</span></span><br><span class="line">    pointer-&gt;<span class="built_in">setSibling</span>(<span class="literal">NULL</span>); <span class="comment">// 设定最后一个节点的兄弟为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带度数的后根次序表示法"><a href="#带度数的后根次序表示法" class="headerlink" title="带度数的后根次序表示法"></a>带度数的后根次序表示法</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026195703505.png" class="" title="image-20241026195703505">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026195723174.png" class="" title="image-20241026195723174">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026195825131.png" class="" title="image-20241026195825131">

<h3 id="带双标记的层次次序表示"><a href="#带双标记的层次次序表示" class="headerlink" title="带双标记的层次次序表示"></a>带双标记的层次次序表示</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026195949175.png" class="" title="image-20241026195949175">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/posts/147acb51/image-20241026200351749.png" class="" title="image-20241026200351749">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 导入输入输出流库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">// 导入队列库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// 导入向量库</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 Tree，表示一棵树，其中 T 是节点存储的数据类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode&lt;T&gt; *root; <span class="comment">// 根节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数：初始化树的根节点为 nullptr</span></span><br><span class="line">    <span class="built_in">Tree</span>() : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数：调用清除函数释放树的节点</span></span><br><span class="line">    ~<span class="built_in">Tree</span>() &#123; <span class="built_in">clear</span>(root); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数：根据双标记的层次次序序列构建树</span></span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">const</span> std::vector&lt;DualTagTreeNode&lt;T&gt;&gt; &amp;nodeArray)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果节点数组为空，则树的根节点为 nullptr</span></span><br><span class="line">        <span class="keyword">if</span> (nodeArray.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;TreeNode&lt;T&gt; *&gt; nodeQueue; <span class="comment">// 队列用于层次遍历构建树</span></span><br><span class="line">        <span class="keyword">auto</span> it = nodeArray.<span class="built_in">begin</span>(); <span class="comment">// 创建一个迭代器，用于遍历节点数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建根节点，并将其信息赋值</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;T&gt;(it-&gt;info);</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;ltag == <span class="number">0</span>) <span class="comment">// 检查根节点是否有左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果根节点有孩子，则将根节点入队</span></span><br><span class="line">            nodeQueue.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        ++it; <span class="comment">// 移动到下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 nodeArray 以构建树</span></span><br><span class="line">        <span class="keyword">while</span> (it != nodeArray.<span class="built_in">end</span>()) <span class="comment">// 直到迭代器达到数组末尾</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeQueue.<span class="built_in">empty</span>()) <span class="comment">// 如果队列为空，说明树结构不合法</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;Invalid level order sequence!&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出错误信息</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;T&gt; *current = nodeQueue.<span class="built_in">front</span>(); <span class="comment">// 获取当前节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理当前节点的孩子</span></span><br><span class="line">            TreeNode&lt;T&gt; *child = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;T&gt;(it-&gt;info); <span class="comment">// 创建孩子节点</span></span><br><span class="line">            current-&gt;child = child; <span class="comment">// 将孩子节点与当前节点关联</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;ltag == <span class="number">0</span>) <span class="comment">// 检查孩子节点是否有左孩子</span></span><br><span class="line">            &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">push</span>(child); <span class="comment">// 如果有左孩子，将其入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;rtag == <span class="number">0</span>) <span class="comment">// 检查孩子节点是否有右兄弟</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果有右兄弟，继续处理兄弟节点</span></span><br><span class="line">                TreeNode&lt;T&gt; *prevSibling = child; <span class="comment">// 记录当前孩子节点作为前一个兄弟</span></span><br><span class="line">                ++it; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">                <span class="keyword">while</span> (it != nodeArray.<span class="built_in">end</span>() &amp;&amp; prevSibling != <span class="literal">nullptr</span>) <span class="comment">// 遍历兄弟节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prevSibling-&gt;sibling != <span class="literal">nullptr</span>) <span class="comment">// 检查前一个兄弟是否已有右兄弟</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 当前节点已经有兄弟，不继续</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    TreeNode&lt;T&gt; *sibling = <span class="keyword">new</span> <span class="built_in">TreeNode</span>&lt;T&gt;(it-&gt;info); <span class="comment">// 创建兄弟节点</span></span><br><span class="line">                    prevSibling-&gt;sibling = sibling; <span class="comment">// 将兄弟节点关联到前一个兄弟上</span></span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;ltag == <span class="number">0</span>) <span class="comment">// 检查兄弟节点是否有左孩子</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        nodeQueue.<span class="built_in">push</span>(sibling); <span class="comment">// 如果有左孩子，将其入队</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (it-&gt;rtag == <span class="number">1</span>) <span class="comment">// 检查兄弟节点是否没有更多兄弟</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 结束兄弟处理</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    prevSibling = sibling; <span class="comment">// 更新前一个兄弟为当前兄弟</span></span><br><span class="line">                    ++it; <span class="comment">// 移动到下一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 如果没有右兄弟</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++it; <span class="comment">// 直接移动到下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (it == nodeArray.<span class="built_in">end</span>()) <span class="comment">// 检查是否达到节点数组末尾</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束构建</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前节点没有更多孩子，出队</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;child == <span class="literal">nullptr</span> || (it-&gt;ltag == <span class="number">1</span> &amp;&amp; it-&gt;rtag == <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                nodeQueue.<span class="built_in">pop</span>(); <span class="comment">// 当前节点出队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 递归释放树的节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(TreeNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果节点不为空，继续递归清除</span></span><br><span class="line">        <span class="keyword">if</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">clear</span>(node-&gt;child); <span class="comment">// 先清除孩子节点</span></span><br><span class="line">            <span class="built_in">clear</span>(node-&gt;sibling); <span class="comment">// 然后清除兄弟节点</span></span><br><span class="line">            <span class="keyword">delete</span> node; <span class="comment">// 删除当前节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pku-cs-cjw.top/image/头像.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pku-cs-cjw.top/image/头像.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">C+V</div><div class="post-copyright__author_desc">万物可爱，你也不例外</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://pku-cs-cjw.top/posts/147acb51/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://pku-cs-cjw.top/posts/147acb51/')">数算复习笔记</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://pku-cs-cjw.top/image/微信.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pku-cs-cjw.top/image/微信.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://pku-cs-cjw.top/image/支付宝.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pku-cs-cjw.top/image/支付宝.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://pku-cs-cjw.top/posts/147acb51/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=数算复习笔记&amp;url=https://pku-cs-cjw.top/posts/147acb51/&amp;pic=/img/default_cover.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pku-cs-cjw.top" target="_blank">C+V</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据结构与算法A<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/dd893702/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">智能</div></div></a></div><div class="next-post pull-right"><a href="/posts/ee040603/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/ee040603/" title="图"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-14</div><div class="title">图</div></div></a></div><div><a href="/posts/cc548c89/" title="内排序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-11-15</div><div class="title">内排序</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5"><span class="toc-number">1.</span> <span class="toc-text">通知</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%80%83%E8%AF%95%E8%8C%83%E5%9B%B4%E5%92%8C%E9%87%8D%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">3. 考试范围和重点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">遗留问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E6%A6%82%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text">第1章 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">3.3.</span> <span class="toc-text">&#x3D;&#x3D;算法分析&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%B8%90%E8%BF%9B%E5%88%86%E6%9E%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">&#x3D;&#x3D;算法的渐进分析&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.3.2.</span> <span class="toc-text">&#x3D;&#x3D;大O表示法&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.3.3.</span> <span class="toc-text">二分查找法时间复杂度推导</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">一、二分查找法的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">二、时间复杂度的推导</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%AF%8F%E4%B8%80%E6%AD%A5%E7%BC%A9%E5%B0%8F%E6%9F%A5%E6%89%BE%E8%8C%83%E5%9B%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.3.2.1.</span> <span class="toc-text">1. 每一步缩小查找范围的大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%A1%AE%E5%AE%9A%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E7%9A%84%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0"><span class="toc-number">3.3.3.2.2.</span> <span class="toc-text">2. 确定最坏情况下需要的比较次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92%E5%85%B3%E7%B3%BB%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.3.3.2.3.</span> <span class="toc-text">3. 递归关系的推导</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.3.2.4.</span> <span class="toc-text">4. 示例说明</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E8%AE%BA"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">三、结论</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">第2章 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.</span> <span class="toc-text">线性表实现方法的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">第3章 栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.</span> <span class="toc-text">&#x3D;&#x3D;栈的性质&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">&#x3D;&#x3D;栈的实现&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84ADT"><span class="toc-number">5.1.2.</span> <span class="toc-text">栈的ADT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">5.1.3.</span> <span class="toc-text">顺序栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">溢出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E6%A0%88"><span class="toc-number">5.1.4.</span> <span class="toc-text">链式栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E6%A0%88%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">链式栈的创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E6%AF%94%E8%BE%83"><span class="toc-number">5.1.5.</span> <span class="toc-text">两者比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%A0%88%E6%9D%A5%E6%B6%88%E9%99%A4%E9%80%92%E5%BD%92"><span class="toc-number">5.2.</span> <span class="toc-text">&#x3D;&#x3D;利用栈来消除递归&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%92%E5%BD%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">简单的递归转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">&#x3D;&#x3D;尾递归&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA%E6%A2%B0%E7%9A%84%E9%80%92%E5%BD%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.2.0.3.</span> <span class="toc-text">&#x3D;&#x3D;机械的递归转换&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E6%9D%A5%E7%9C%8B%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC"><span class="toc-number">5.2.0.3.1.</span> <span class="toc-text">我们来看递归版本</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E6%B3%95%E5%87%BA%E6%A0%88%E5%BA%8F%E5%88%97"><span class="toc-number">5.3.</span> <span class="toc-text">&#x3D;&#x3D;合法出栈序列&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">5.4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84ADT"><span class="toc-number">5.4.1.</span> <span class="toc-text">队列的ADT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">5.4.2.</span> <span class="toc-text">&#x3D;&#x3D;循环队列&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97"><span class="toc-number">5.4.3.</span> <span class="toc-text">链式队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">作业题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">6.</span> <span class="toc-text">第4章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84KMP%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">串的KMP快速模式匹配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">6.1.1.</span> <span class="toc-text">算法复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">第5章 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">思考题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.2.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.2.2.</span> <span class="toc-text">完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.3.</span> <span class="toc-text">扩充二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%80%A7%E8%B4%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">重要性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8"><span class="toc-number">7.4.</span> <span class="toc-text">&#x3D;&#x3D;二叉树的周游&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">7.4.1.</span> <span class="toc-text">&#x3D;&#x3D;非递归深度优先遍历&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.4.2.</span> <span class="toc-text">&#x3D;&#x3D;广度优先遍历二叉树&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">7.5.</span> <span class="toc-text">&#x3D;&#x3D;二叉搜索树的插入和删除&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">7.5.1.</span> <span class="toc-text">二叉搜索树的插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AA%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.1.2.1.</span> <span class="toc-text">未优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">7.5.1.2.2.</span> <span class="toc-text">改进</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="toc-number">7.6.</span> <span class="toc-text">&#x3D;&#x3D;堆的建立和维护&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0Huffman%E6%A0%91%EF%BC%8C%E5%88%A9%E7%94%A8Huffman%E6%A0%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E3%80%81%E8%A7%A3%E7%A0%81"><span class="toc-number">7.6.1.</span> <span class="toc-text">&#x3D;&#x3D;构造Huffman树，利用Huffman树进行编码、解码&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8BHuffman%E7%BC%96%E7%A0%81%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.6.2.</span> <span class="toc-text">建立Huffman编码树的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-number">7.6.3.</span> <span class="toc-text">编码过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%91%E7%A0%81"><span class="toc-number">7.6.4.</span> <span class="toc-text">译码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">第6章 树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.</span> <span class="toc-text">&#x3D;&#x3D;森林和二叉树的相互转换&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.1.1.</span> <span class="toc-text">森林转换成二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E6%8D%A2%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.1.2.</span> <span class="toc-text">树换成二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E6%A3%AE%E6%9E%97"><span class="toc-number">8.1.3.</span> <span class="toc-text">二叉树转换成森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%BA%E6%A0%91"><span class="toc-number">8.1.4.</span> <span class="toc-text">二叉树为树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%91%A8%E6%B8%B8"><span class="toc-number">8.2.</span> <span class="toc-text">树的周游</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">&#x3D;&#x3D;树的链式存储&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E6%8C%87%E9%92%88%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%8F%8A%E5%9C%A8%E5%B9%B6%E6%9F%A5%E9%9B%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">&#x3D;&#x3D;父指针表示法及在并查集中的应用&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">8.3.1.</span> <span class="toc-text">并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">&#x3D;&#x3D;树的顺序存储方法&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%B3%E9%93%BE%E7%9A%84%E5%85%88%E6%A0%B9%E6%AC%A1%E5%BA%8F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">8.4.1.</span> <span class="toc-text">带右链的先根次序表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%8C%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%9A%84%E5%85%88%E6%A0%B9%E6%AC%A1%E5%BA%8F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">8.4.2.</span> <span class="toc-text">带双标记位的先根次序表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%BA%A6%E6%95%B0%E7%9A%84%E5%90%8E%E6%A0%B9%E6%AC%A1%E5%BA%8F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">8.4.3.</span> <span class="toc-text">带度数的后根次序表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%8F%8C%E6%A0%87%E8%AE%B0%E7%9A%84%E5%B1%82%E6%AC%A1%E6%AC%A1%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">8.4.4.</span> <span class="toc-text">带双标记的层次次序表示</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/C%2BV-%E4%B8%8A%E8%AF%BE%E6%91%B8%E9%B1%BC%E4%B8%AD-yellow?style=plastic&amp;labelColor=blue&amp;cacheSeconds=100000000" alt="距离月入100k也就还差一个大佬带我~" title="距离月入100k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><div class="footer_custom_text">感谢访问我的博客！</div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="C+V" target="_blank">C+V</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  fetch('https://v1.hitokoto.cn')
    .then(response => response.json())
    .then(data => {
      if (true) {
        const from = '出自 ' + data.from
        const sub = ["生活明朗&#44; 万物可爱&#44; 人间值得&#44; 未来可期."]
        sub.unshift(data.hitokoto, from)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = data.hitokoto
      }
    })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/187370" title="github"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="github"/><span class="back-menu-item-text">github</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/YuanQiPKU/Reservoir" title="账目管理"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="账目管理"/><span class="back-menu-item-text">账目管理</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/%E8%AE%A2%E9%98%85%E6%88%91%E5%90%A7"><span> 订阅我吧</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about-this-wed"><span> 关于此站</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/CSAPP/" style="font-size: 0.88rem; color: rgb(112, 200, 49);">CSAPP<sup>3</sup></a><a href="/tags/ICS/" style="font-size: 0.88rem; color: rgb(79, 138, 16);">ICS<sup>1</sup></a><a href="/tags/ics/" style="font-size: 0.88rem; color: rgb(197, 90, 89);">ics<sup>2</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem; color: rgb(99, 99, 78);">教程<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95A/" style="font-size: 0.88rem; color: rgb(51, 85, 115);">数据结构与算法A<sup>3</sup></a><a href="/tags/%E6%95%B0%E7%AE%97/" style="font-size: 0.88rem; color: rgb(37, 84, 131);">数算<sup>1</sup></a><a href="/tags/%E6%B0%B4%E6%96%87/" style="font-size: 0.88rem; color: rgb(102, 179, 174);">水文<sup>2</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem; color: rgb(180, 176, 171); font-weight: 500; color: var(--anzhiyu-lighttext)">笔记<sup>6</sup></a><a href="/tags/%E9%B8%A1%E6%B1%A4/" style="font-size: 0.88rem; color: rgb(151, 136, 168);">鸡汤<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("08/25/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 C+V 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("08/25/2024 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://img.shields.io/badge/C%2BV-%E4%B8%8B%E8%AF%BE%E4%B9%9F%E8%A6%81%E6%91%B8%E9%B1%BC-yellow?style=plastic&amp;labelColor=blue&amp;cacheSeconds=100000000";
        img.title = "下课了就该开开心心的，嘿嘿~";
        img.alt = "下课了就该开开心心的，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'UScCBdqZnuOfbLRqTwMpFe7v-gzGzoHsz',
      appKey: '7wZOJ9tynvwyBo9vebjOU8MY',
      avatar: 'identicon',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=identicon'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://UScCBdqZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'UScCBdqZnuOfbLRqTwMpFe7v-gzGzoHsz',
        "X-LC-Key": '7wZOJ9tynvwyBo9vebjOU8MY',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = false

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = {
      startHidden: true
    }
  
    window.chatBtnFn = () => {
      const isShow = document.getElementById('chatra').classList.contains('chatra--expanded')
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        Chatra('hide')
      },
      show: () => {
        Chatra('show')
      }
    }
  }

  (function(d, w, c) {
    w.ChatraID = 'HRMxBqTEvboxGRPzB'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')

})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习笔记/&quot;);" href="javascript:void(0);">学习笔记</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr">学习笔记</span></li><li class="categoryBar-list-item" style="background:url(https://npm.elemecdn.com/akilar-candyassets/image/cover2.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/大学生涯/&quot;);" href="javascript:void(0);">大学生涯</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">大学生涯</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>